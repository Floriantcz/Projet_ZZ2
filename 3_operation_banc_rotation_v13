#!/usr/bin/env python3
"""
Accelerometer calibration bench pilot - Zigzag Version (Dynamic Step)
Modifications:
 - Ajout d'une saisie utilisateur pour le pas de Psi
 - Validation que le pas est un diviseur de 360
"""

import argparse
import json
import csv
import math
import socket
import threading
import time
from datetime import datetime
from typing import List, Optional, Tuple

# ---------------- Config ----------------
HOST = "192.168.4.1"
PORT = 3535
SERIAL_PORT = "COM7"
BAUDRATE = 115200

SENSITIVITY = 256000.0  # LSB/g
MOTOR_SPEED = 30
OMEGA_EST = 8.04  # deg/s @ MOTOR_SPEED
KP_FINE = 2.0
ANGLE_TOL = 1.0
CONTROL_PERIOD = 0.05
SETTLE_TIMEOUT = 8.0
STABLE_DURATION = 1.5
STABLE_TOL = 0.008
SOCKET_TIMEOUT = 1.0

# ---------------- Shared state ----------------
accel_lock = threading.Lock()
latest_theta: Optional[float] = None
latest_psi_unwrapped: Optional[float] = None
latest_accel_g: Optional[Tuple[float, float, float]] = None
latest_raw_lsb: Optional[Tuple[int, int, int]] = None
latest_raw_ts: Optional[str] = None
running_event = threading.Event()

# ---------------- Utilities ----------------
def _now_iso() -> str:
    return datetime.utcnow().isoformat(timespec="microseconds") + "Z"

def lsb_to_g(ax_lsb: int, ay_lsb: int, az_lsb: int) -> Tuple[float, float, float]:
    return ax_lsb / SENSITIVITY, ay_lsb / SENSITIVITY, az_lsb / SENSITIVITY

def compute_theta_signed(ax_g: float, ay_g: float, az_g: float) -> float:
    eps = 1e-12
    return math.degrees(math.atan2(ax_g, math.sqrt(ay_g*ay_g + az_g*az_g + eps)))

def compute_psi_signed(ax_g: float, ay_g: float, az_g: float) -> float:
    """Psi réel moteur [-180,180]"""
    return math.degrees(math.atan2(ay_g, az_g))

def normalize_angle(angle: float) -> float:
    return (angle + 180.0) % 360.0 - 180.0

def parse_asc3_line(line: str) -> Optional[Tuple[int, int, int]]:
    parts = line.strip().split()
    if len(parts) < 5 or parts[0] != "ASC3": return None
    try: return int(parts[2]), int(parts[3]), int(parts[4])
    except ValueError: return None

def load_scan_config(path: str) -> list:
    try:
        with open(path, "r") as f:
            cfg = json.load(f)

        seq = cfg.get("scan_sequence")
        if not seq or not isinstance(seq, list):
            raise ValueError("scan_sequence invalide")

        for step in seq:
            if "theta_deg" not in step:
                raise ValueError("theta_deg manquant")
            if "psi_steps_deg" in step:
                steps = step["psi_steps_deg"]
                if not all(s > 0 for s in steps):
                    raise ValueError("psi_steps_deg invalide")

        print("Configuration scan chargée avec succès")
        return seq

    except Exception as e:
        print(f"Erreur config JSON : {e}")
        raise

def accel_reader_thread(sock: socket.socket):
    global latest_theta, latest_psi_unwrapped, latest_accel_g, latest_raw_lsb, latest_raw_ts

    buf = ""
    sock.settimeout(SOCKET_TIMEOUT)

    while running_event.is_set():
        try:
            data = sock.recv(4096)
            if not data:
                break

            buf += data.decode(errors="ignore")
            lines = buf.split("\n")
            buf = lines[-1]

            for line in lines[:-1]:
                parsed = parse_asc3_line(line)
                if not parsed:
                    continue

                ax_lsb, ay_lsb, az_lsb = parsed
                ax_g, ay_g, az_g = lsb_to_g(ax_lsb, ay_lsb, az_lsb)

                # Theta inchangé
                theta_signed = compute_theta_signed(ax_g, ay_g, az_g)

                psi_signed = math.degrees(math.atan2(ay_g, az_g))
                psi_signed = (psi_signed + 180.0) % 360.0 - 180.0

                with accel_lock:
                    prev = latest_psi_unwrapped

                    if prev is None:
                        psi_unwrapped = psi_signed
                    else:
                        k = round((prev - psi_signed) / 360.0)
                        psi_unwrapped = psi_signed + 360.0 * k

                    latest_theta = theta_signed
                    latest_psi_unwrapped = psi_unwrapped
                    latest_accel_g = (ax_g, ay_g, az_g)
                    latest_raw_lsb = (ax_lsb, ay_lsb, az_lsb)
                    latest_raw_ts = _now_iso()

        except socket.timeout:
            continue
        except Exception as e:
            print(f"[AccelReader] error: {e}")
            time.sleep(0.05)

def wait_for_settle(timeout: float = SETTLE_TIMEOUT, stable_duration: float = STABLE_DURATION, tol: float = STABLE_TOL) -> bool:
    t_start = time.time()
    stable_start: Optional[float] = None
    last_norm: Optional[float] = None
    while running_event.is_set():
        with accel_lock:
            accel = latest_accel_g
        if accel is None:
            if time.time() - t_start > timeout: return False
            time.sleep(CONTROL_PERIOD)
            continue
        norm = math.sqrt(accel[0]**2 + accel[1]**2 + accel[2]**2)
        if last_norm is None or abs(norm - last_norm) <= tol:
            if stable_start is None: stable_start = time.time()
            elif time.time() - stable_start >= stable_duration: return True
        else: stable_start = None
        last_norm = norm
        if time.time() - t_start > timeout: return False
        time.sleep(CONTROL_PERIOD)
    return False

# ---------------- Motor helpers ----------------
def send_command(ser_obj, cmd: str):
    try:
        ser_obj.write((cmd + "\n").encode())
        if hasattr(ser_obj, "flush"): ser_obj.flush()
    except Exception as e: print(f"[send_command] {e} cmd={cmd}")

def stop_all(ser_obj):
    send_command(ser_obj, "?stopall")

class SerialStub:
    def write(self, b): print(f"[SerialStub] -> {b.decode().strip()}")
    def flush(self): pass
    def close(self): pass

def build_serial_obj(serial_port: str, baud: int):
    try:
        import serial
        return serial.Serial(serial_port, baud, timeout=1.0)
    except Exception:
        return SerialStub()

# ---------------- Control routines ----------------

def move_theta(target: float, ser_obj, theta_cmd_holder: dict):
    print(f"\n→ move_theta: {target:.1f}°")
    with accel_lock:
        current_theta = latest_theta if latest_theta is not None else theta_cmd_holder["theta_cmd"]
    delta = target - current_theta
    if abs(delta) < 0.2: return
    direction = 1 if delta > 0 else -1
    t_coarse = min(abs(delta) / max(OMEGA_EST, 1e-6) * 1.1, 90.0)
    send_command(ser_obj, f"?m1={direction * MOTOR_SPEED}")
    t0 = time.time()
    while running_event.is_set() and (time.time() - t0) < t_coarse:
        with accel_lock:
            th = latest_theta
        if th is not None and abs(target - th) < 3.0: break
        time.sleep(CONTROL_PERIOD)
    stop_all(ser_obj)
    fine_start = time.time()
    while running_event.is_set() and (time.time() - fine_start) < 15.0:
        with accel_lock:
            th = latest_theta
        if th is None or abs(target - th) <= ANGLE_TOL: break
        cmd = max(min(KP_FINE * (target - th), MOTOR_SPEED), -MOTOR_SPEED)
        send_command(ser_obj, f"?m1={int(round(cmd))}")
        time.sleep(CONTROL_PERIOD)
    stop_all(ser_obj)
    theta_cmd_holder["theta_cmd"] = target
    wait_for_settle(timeout=2.0, stable_duration=0.5)

def move_psi_direct(target: float, ser_obj):
    with accel_lock:
        current = latest_psi_unwrapped if latest_psi_unwrapped is not None else 0.0
    delta = target - current
    if abs(delta) < 1.0: return
    print(f"→ move_psi_direct: to {target:.1f}°")
    direction = 1 if delta > 0 else -1
    t_move = abs(delta) / max(OMEGA_EST, 1e-6)
    send_command(ser_obj, f"?m2={direction * MOTOR_SPEED}")
    time.sleep(t_move)
    stop_all(ser_obj)
    wait_for_settle(timeout=4.0, stable_duration=0.8)

def sweep_psi_variable(theta_deg: float, ser_obj, dataset: list, start_pos: float, psi_steps: list) -> float:
    current = start_pos
    direction = -1 if start_pos > 0 else 1  # sens du mouvement
    
    print(f"→ sweep_psi_variable: Theta={theta_deg}°, start={start_pos}°")
    
    for step_deg in psi_steps:
        # attendre que le système soit stable
        wait_for_settle()

        # lire l'accélération
        with accel_lock:
            psi_meas = latest_psi_unwrapped
            theta_meas = latest_theta
            accel = latest_accel_g
            raw = latest_raw_lsb
            ts = latest_raw_ts

        if accel and raw:
            normg = math.sqrt(sum(a*a for a in accel))
            dataset.append([ts or _now_iso(), theta_deg, theta_meas, psi_meas, raw[0], raw[1], raw[2], normg])
            print(f"   [Data] Psi={psi_meas:.1f}° (step={step_deg}°)")

        # déplacer le moteur
        current += direction * step_deg
        t_move = step_deg / max(OMEGA_EST, 1e-6)
        send_command(ser_obj, f"?m2={direction * MOTOR_SPEED}")
        time.sleep(t_move)
        stop_all(ser_obj)

    return current

# ---------------- Main Logic ----------------
def run_scan_sequence(host: str, port: int, ser_obj):
    # Charger la configuration complète
    scan_sequence = load_scan_config("psi_steps.json")

    running_event.set()
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    try:
        sock.connect((host, port))
    except Exception as e:
        print(f"Connect error: {e}")
        return

    # Lancer le thread de lecture de l'accéléromètre
    reader = threading.Thread(target=accel_reader_thread, args=(sock,), daemon=True)
    reader.start()

    theta_cmd_holder = {"theta_cmd": 0.0}
    dataset = []
    current_psi = 0.0  # Position courante de psi

    try:
        stop_all(ser_obj)

        # Boucle sur chaque step de la séquence
        for idx, step in enumerate(scan_sequence):
            theta = step["theta_deg"]
            psi_start = step.get("psi_start_deg", current_psi)
            psi_steps = step.get("psi_steps_deg", [])

            print(f"\n=== STEP {idx+1}/{len(scan_sequence)} : Theta={theta}° ===")

            # Déplacer theta
            move_theta(theta, ser_obj, theta_cmd_holder)

            # Déplacer psi à la position initiale du step si nécessaire
            if abs(psi_start - current_psi) > 1.0:
                move_psi_direct(psi_start, ser_obj)
                current_psi = psi_start

            # Balayage psi si steps définis
            if psi_steps:
                current_psi = sweep_psi_variable(theta, ser_obj, dataset, current_psi, psi_steps)
            else:
                # Mesure statique si pas de balayage
                wait_for_settle()
                with accel_lock:
                    if latest_accel_g:
                        normg = math.sqrt(sum(x*x for x in latest_accel_g))
                        dataset.append([latest_raw_ts or _now_iso(), theta, latest_theta, latest_psi_unwrapped, latest_raw_lsb[0], latest_raw_lsb[1], latest_raw_lsb[2], normg])
                        print(f"   [Data Stat] Psi={latest_psi_unwrapped:.1f}°")

        # Après toute la séquence, retour de psi à 0°
        print("\n=== FINAL POSITIONING: Return Psi to 0° ===")
        move_psi_direct(0.0, ser_obj)
        current_psi = 0.0

        # Sauvegarder le dataset
        fname = f"scan_zigzag_{int(time.time())}.csv"
        with open(fname, "w", newline="") as f:
            writer = csv.writer(f)
            writer.writerow(["time_utc", "theta_cmd_deg", "theta_meas_deg", "psi_unwrapped_deg", "x_lsb", "y_lsb", "z_lsb", "norm_g"])
            writer.writerows(dataset)
        print(f"Done. Saved to {fname}")

    finally:
        running_event.clear()
        stop_all(ser_obj)
        sock.close()
        reader.join(1.0)

if __name__ == "__main__":
    ser = build_serial_obj(SERIAL_PORT, BAUDRATE)
    run_scan_sequence(HOST, PORT, ser)