#!/usr/bin/env python3
"""
Accelerometer calibration bench pilot
- Theta limited to [-90, +90] but extended for ±180 theoretical sweep
- Continuous/unwrapped psi
- Recalibration at each step using last N Theta measurements
- Fast return from 180 -> 0 and -180 -> 0
"""

import argparse
import csv
import math
import socket
import threading
import time
from datetime import datetime
from typing import List, Optional, Tuple

# ---------------- Config (tune as needed) ----------------
HOST = "192.168.4.1"
PORT = 3535

SERIAL_PORT = "COM7"
BAUDRATE = 115200

SENSITIVITY = 256000.0  # LSB/g

THETA_STEP = 30
PSI_STEP = 30
PSI_SWEEP = 360
N_PSI_STEPS = int(PSI_SWEEP / PSI_STEP)

MOTOR_SPEED = 30
OMEGA_EST = 8.04  # deg/s @ MOTOR_SPEED (calibrate)

KP_FINE = 2.0
ANGLE_TOL = 1.0  # deg
RAPID_RETURN_SPEED = 60  # deg/s for fast return

CONTROL_PERIOD = 0.05

SETTLE_TIMEOUT = 8.0
STABLE_DURATION = 1.5
STABLE_TOL = 0.008

ACCEL_NORM_MIN = 0.7
ACCEL_NORM_MAX = 1.3

SOCKET_TIMEOUT = 1.0

# ---------------- Shared state ----------------
accel_lock = threading.Lock()
latest_theta: Optional[float] = None
latest_theta_extended: Optional[float] = None  # MODIF
latest_psi_unwrapped: Optional[float] = None
latest_accel_g: Optional[Tuple[float, float, float]] = None
latest_raw_lsb: Optional[Tuple[int, int, int]] = None
latest_raw_ts: Optional[str] = None

running_event = threading.Event()

# ---------------- Utilities ----------------
def _now_iso() -> str:
    return datetime.utcnow().isoformat(timespec="microseconds") + "Z"

def lsb_to_g(ax_lsb: int, ay_lsb: int, az_lsb: int) -> Tuple[float, float, float]:
    return ax_lsb / SENSITIVITY, ay_lsb / SENSITIVITY, az_lsb / SENSITIVITY

def circular_distance(a: float, b: float) -> float:
    return abs((a - b + 180.0) % 360.0 - 180.0)

# ---------------- Angle computation ----------------
def compute_theta_signed(ax_g: float, ay_g: float, az_g: float) -> float:
    eps = 1e-12
    return math.degrees(math.atan2(ax_g, math.sqrt(ay_g*ay_g + az_g*az_g + eps)))

def compute_theta_extended(ax_g: float, ay_g: float, az_g: float, prev_theta_ext: Optional[float]) -> float:
    """
    Theta extended: remap 0..90 -> 0..180 or 0..-180 using az sign
    """
    theta_signed = compute_theta_signed(ax_g, ay_g, az_g)
    Z_HYST = 0.02
    if prev_theta_ext is None:
        prev_theta_ext = theta_signed
    if az_g < -Z_HYST:
        # hemisphere “back”
        if theta_signed >= 0:
            theta_ext = 180.0 - theta_signed
        else:
            theta_ext = -180.0 - theta_signed
    elif az_g > Z_HYST:
        theta_ext = theta_signed
    else:
        theta_ext = prev_theta_ext
    return theta_ext

def compute_psi_base(ax_g: float, ay_g: float, az_g: float) -> float:
    eps = 1e-12
    alpha_psi = math.degrees(math.atan2(ay_g, math.sqrt(ax_g*ax_g + az_g*az_g + eps)))
    if az_g < 0.0:
        psi = 180.0 - alpha_psi
    else:
        psi = alpha_psi
    return psi % 360.0

# ---------------- ASC3 parsing & accel reader ----------------
def parse_asc3_line(line: str) -> Optional[Tuple[int, int, int]]:
    parts = line.strip().split()
    if len(parts) < 5 or parts[0] != "ASC3":
        return None
    try:
        ax = int(parts[2])
        ay = int(parts[3])
        az = int(parts[4])
        return ax, ay, az
    except ValueError:
        return None

def accel_reader_thread(sock: socket.socket):
    global latest_theta, latest_theta_extended, latest_psi_unwrapped, latest_accel_g, latest_raw_lsb, latest_raw_ts
    buf = ""
    sock.settimeout(SOCKET_TIMEOUT)
    while running_event.is_set():
        try:
            data = sock.recv(4096)
            if not data:
                running_event.clear()
                break
            buf += data.decode(errors="ignore")
            lines = buf.split("\n")
            buf = lines[-1]
            for line in lines[:-1]:
                parsed = parse_asc3_line(line)
                if not parsed:
                    continue
                ax_lsb, ay_lsb, az_lsb = parsed
                ax_g, ay_g, az_g = lsb_to_g(ax_lsb, ay_lsb, az_lsb)

                theta_signed = compute_theta_signed(ax_g, ay_g, az_g)
                with accel_lock:
                    theta_ext = compute_theta_extended(ax_g, ay_g, az_g, latest_theta_extended)
                    latest_theta_extended = theta_ext

                psi_base = compute_psi_base(ax_g, ay_g, az_g)

                with accel_lock:
                    prev_unwrapped = latest_psi_unwrapped
                    candidates_base = [psi_base % 360.0, (psi_base + 180.0) % 360.0]
                    chosen_unwrapped = candidates_base[0] if prev_unwrapped is None else min(
                        (b + 360.0*round((prev_unwrapped-b)/360.0) for b in candidates_base),
                        key=lambda u: abs(u-prev_unwrapped)
                    )
                    latest_theta = theta_signed
                    latest_psi_unwrapped = chosen_unwrapped
                    latest_accel_g = (ax_g, ay_g, az_g)
                    latest_raw_lsb = (ax_lsb, ay_lsb, az_lsb)
                    latest_raw_ts = _now_iso()
        except socket.timeout:
            continue
        except Exception as e:
            print(f"[AccelReader] error: {e}")
            time.sleep(0.05)

# ---------------- Settling wait ----------------
def wait_for_settle(timeout: float = SETTLE_TIMEOUT,
                    stable_duration: float = STABLE_DURATION,
                    tol: float = STABLE_TOL) -> bool:
    t_start = time.time()
    stable_start: Optional[float] = None
    last_norm: Optional[float] = None
    while running_event.is_set():
        with accel_lock:
            accel = latest_accel_g
        if accel is None:
            if time.time() - t_start > timeout:
                return False
            time.sleep(CONTROL_PERIOD)
            continue

        norm = math.sqrt(accel[0]**2 + accel[1]**2 + accel[2]**2)
        if last_norm is None or abs(norm - last_norm) <= tol:
            stable_start = stable_start or time.time()
            if time.time() - stable_start >= stable_duration:
                return True
        else:
            stable_start = None
        last_norm = norm

        if time.time() - t_start > timeout:
            return False
        time.sleep(CONTROL_PERIOD)
    return False

# ---------------- Motor helpers ----------------
def send_command(ser_obj, cmd: str):
    try:
        out = (cmd + "\n").encode()
        ser_obj.write(out)
        if hasattr(ser_obj, "flush"):
            try:
                ser_obj.flush()
            except Exception:
                pass
    except Exception as e:
        print(f"[send_command] {e} cmd={cmd}")

def stop_all(ser_obj):
    send_command(ser_obj, "?stopall")

class SerialStub:
    def write(self, b):
        s = b.decode() if isinstance(b, (bytes, bytearray)) else str(b)
        s = s.strip()
        print(f"[SerialStub] -> {s}")
    def flush(self):
        pass
    def close(self):
        pass

def build_serial_obj(serial_port: str = SERIAL_PORT, baud: int = BAUDRATE):
    try:
        import serial
        ser = serial.Serial(serial_port, baud, timeout=1.0)
        time.sleep(0.1)
        return ser
    except Exception:
        return SerialStub()

# ---------------- Control routines ----------------
def move_theta(target: float, ser_obj, theta_cmd_holder: dict, rapid_return: bool = False):
    delta_cmd = target - theta_cmd_holder["theta_cmd"]
    if abs(delta_cmd) < 0.1:
        return

    direction = 1 if delta_cmd > 0 else -1
    abs_delta = abs(delta_cmd)
    omega = RAPID_RETURN_SPEED if rapid_return else OMEGA_EST
    t_est = abs_delta / max(omega, 1e-6)
    t_coarse = min(t_est * 1.1, 90.0)
    send_command(ser_obj, f"?m1={direction * MOTOR_SPEED}")
    t0 = time.time()
    stopped = False
    while running_event.is_set() and (time.time()-t0) < t_coarse*2.0:
        with accel_lock:
            th = latest_theta_extended
        if th is not None and abs(target - th) < 3.0:
            stop_all(ser_obj)
            stopped = True
            break
        time.sleep(CONTROL_PERIOD)
    if not stopped:
        stop_all(ser_obj)

    # Fine correction
    with accel_lock:
        accel = latest_accel_g
    reliable = accel is not None and ACCEL_NORM_MIN <= math.sqrt(accel[0]**2 + accel[1]**2 + accel[2]**2) <= ACCEL_NORM_MAX
    if reliable:
        fine_start = time.time()
        while running_event.is_set() and time.time()-fine_start < 30.0:
            with accel_lock:
                th = latest_theta_extended
            if th is None:
                break
            err = target - th
            if abs(err) <= ANGLE_TOL:
                break
            cmd = KP_FINE * err
            cmd = max(min(cmd, MOTOR_SPEED), -MOTOR_SPEED)
            send_command(ser_obj, f"?m1={int(round(cmd))}")
            time.sleep(CONTROL_PERIOD)
    stop_all(ser_obj)
    theta_cmd_holder["theta_cmd"] = target
    wait_for_settle(timeout=2.0, stable_duration=0.4, tol=STABLE_TOL)

# ---------------- Recalibration ----------------
def recalibrate_theta_step(theta_target: float, ser_obj, theta_cmd_holder: dict,
                           N_samples: int = 10, epsilon: float = 1.5):
    samples: List[float] = []
    for _ in range(N_samples):
        with accel_lock:
            th = latest_theta_extended
        if th is not None:
            samples.append(th)
        time.sleep(0.01)
    if not samples:
        return
    mean_theta = sum(samples)/len(samples)
    err = theta_target - mean_theta
    if abs(err) > epsilon:
        move_theta(theta_target, ser_obj, theta_cmd_holder)

# ---------------- PSI sweep ----------------
def sweep_psi_stepwise(direction: int, theta_deg: float, ser_obj, dataset: List[List]):
    t_step = PSI_STEP / max(OMEGA_EST, 1e-6)
    t_step = min(t_step, 60.0)
    for k in range(N_PSI_STEPS):
        if not running_event.is_set():
            break
        send_command(ser_obj, f"?m2={direction*MOTOR_SPEED}")
        time.sleep(t_step)
        stop_all(ser_obj)
        wait_for_settle(timeout=SETTLE_TIMEOUT, stable_duration=STABLE_DURATION, tol=STABLE_TOL)
        with accel_lock:
            psi_unwrapped = latest_psi_unwrapped
            theta_meas = latest_theta_extended
            accel = latest_accel_g
            raw = latest_raw_lsb
            raw_ts = latest_raw_ts
        log_time = raw_ts if raw_ts is not None else _now_iso()
        if accel is not None and theta_meas is not None and psi_unwrapped is not None and raw is not None:
            normg = math.sqrt(accel[0]**2 + accel[1]**2 + accel[2]**2)
            dataset.append([log_time, theta_deg, theta_meas, psi_unwrapped, raw[0], raw[1], raw[2], normg])
        recalibrate_theta_step(theta_deg, ser_obj, {"theta_cmd": theta_deg})  # recalibration

# ---------------- Dataset IO ----------------
def save_dataset_csv(dataset: List[List], prefix: str = "scan_dataset") -> Optional[str]:
    if not dataset:
        return None
    fname = f"{prefix}_{int(time.time())}.csv"
    try:
        with open(fname, "w", newline="") as f:
            writer = csv.writer(f)
            writer.writerow(["time_utc","theta_cmd_deg","theta_meas_deg","psi_unwrapped_deg","x_lsb","y_lsb","z_lsb","norm_g"])
            writer.writerows(dataset)
        return fname
    except Exception:
        return None

# ---------------- Top-level sequence ----------------
def run_scan_sequence(host: str, port: int, ser_obj):
    running_event.set()
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    try:
        sock.connect((host, port))
    except Exception:
        running_event.clear()
        return
    reader = threading.Thread(target=accel_reader_thread, args=(sock,), daemon=True)
    reader.start()

    theta_cmd_holder = {"theta_cmd": 0.0}
    dataset: List[List] = []

    sequence = [
        {"theta":0.0,"psi_sweep":False,"psi_dir":1},
        {"theta":90.0,"psi_sweep":False,"psi_dir":1},
        {"theta":180.0,"psi_sweep":True,"psi_dir":1},  # étendu jusqu'à 180
        {"theta":0.0,"psi_sweep":False,"psi_dir":1,"rapid_return":True},
        {"theta":-180.0,"psi_sweep":True,"psi_dir":-1},
        {"theta":0.0,"psi_sweep":False,"psi_dir":1,"rapid_return":True}
    ]

    try:
        for step in sequence:
            target_theta = step["theta"]
            psi_sweep = step.get("psi_sweep", False)
            psi_dir = step.get("psi_dir", 1)
            rapid_return = step.get("rapid_return", False)

            move_theta(target_theta, ser_obj, theta_cmd_holder, rapid_return=rapid_return)
            if psi_sweep:
                sweep_psi_stepwise(psi_dir, target_theta, ser_obj, dataset)
            else:
                wait_for_settle()
                recalibrate_theta_step(target_theta, ser_obj, theta_cmd_holder)

    finally:
        running_event.clear()
        stop_all(ser_obj)
        try: sock.close()
        except Exception: pass
        if hasattr(ser_obj,"close"): ser_obj.close()
        reader.join(timeout=1.0)
        save_dataset_csv(dataset)

# ---------------- CLI ----------------
def parse_args():
    p = argparse.ArgumentParser(description="Accelerometer pilot ±180° theta_extended")
    p.add_argument("--host", default=HOST)
    p.add_argument("--port", type=int, default=PORT)
    p.add_argument("--serial", default=SERIAL_PORT)
    p.add_argument("--baud", type=int, default=BAUDRATE)
    return p.parse_args()

def main():
    args = parse_args()
    ser_obj = build_serial_obj(args.serial, args.baud)
    run_scan_sequence(args.host, args.port, ser_obj)

if __name__ == "__main__":
    main()
