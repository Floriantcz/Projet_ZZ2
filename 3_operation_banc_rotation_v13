#!/usr/bin/env python3
"""
Accelerometer calibration bench pilot (theta limited to [-90, +90], continuous/unwrapped psi)

Changes vs. prior version:
 - Theta is kept as a signed angle in degrees in the range approximately [-90, +90]
   (computed directly from atan2, no 0..360 remapping or az-based 180° correction).
 - Psi is computed as a base candidate (0..360) similar to before, but then an
   unwrapped psi value is maintained so that rotations accumulate continuously
   (psi can exceed 360° or go below 0°). This prevents artificial extra-turn
   jumps when the accelerometer's psi candidate flips by ±180°.
 - move_theta uses linear (non-circular) error because theta is not circular
   in this application (we only allow approx. -90..+90).
"""

import argparse
import csv
import math
import socket
import threading
import time
from datetime import datetime
from typing import List, Optional, Tuple

# ---------------- Config (tune as needed) ----------------
HOST = "192.168.4.1"
PORT = 3535

SERIAL_PORT = "COM7"
BAUDRATE = 115200

SENSITIVITY = 256000.0  # LSB/g

THETA_STEP = 30
# We no longer use MAX_THETA as a 0..360 sweep; theta will be in [-90, +90]

PSI_SWEEP = 360
PSI_STEP = 30
N_PSI_STEPS = int(PSI_SWEEP / PSI_STEP)

MOTOR_SPEED = 30
OMEGA_EST = 8.04  # deg/s @ MOTOR_SPEED (calibrate)

KP_FINE = 2.0
ANGLE_TOL = 1.0  # deg

CONTROL_PERIOD = 0.05

# Settling parameters
SETTLE_TIMEOUT = 8.0      # max seconds to wait for settling at each step
STABLE_DURATION = 1.5     # seconds of consecutive stable readings required
STABLE_TOL = 0.008        # g change tolerated during stable window (in g)

# Accel norm sanity bounds
ACCEL_NORM_MIN = 0.7
ACCEL_NORM_MAX = 1.3

SOCKET_TIMEOUT = 1.0

AZ_EPS = 0.03  # g, hysteresis threshold

# ---------------- Shared state ----------------
accel_lock = threading.Lock()
latest_theta: Optional[float] = None            # signed theta in degrees (~-90..+90)
latest_psi_unwrapped: Optional[float] = None    # continuous psi (can exceed 360)
latest_accel_g: Optional[Tuple[float, float, float]] = None
latest_raw_lsb: Optional[Tuple[int, int, int]] = None
latest_raw_ts: Optional[str] = None              # ISO timestamp of latest ASC3 processed

running_event = threading.Event()

# ---------------- Utilities ----------------
def _now_iso() -> str:
    return datetime.utcnow().isoformat(timespec="microseconds") + "Z"

def lsb_to_g(ax_lsb: int, ay_lsb: int, az_lsb: int) -> Tuple[float, float, float]:
    return ax_lsb / SENSITIVITY, ay_lsb / SENSITIVITY, az_lsb / SENSITIVITY

def circular_distance(a: float, b: float) -> float:
    """Minimal absolute circular distance between angles a and b (both in degrees)."""
    return abs((a - b + 180.0) % 360.0 - 180.0)

# ---------------- Angle computation (theta signed, psi base) ----------------
"""
def compute_theta_signed(ax_g: float, ay_g: float, az_g: float) -> float:
    
    #Compute signed theta in degrees (approx range -90..+90).
    #theta = atan2(ax, sqrt(ay^2 + az^2))

    eps = 1e-12
    theta_deg = math.degrees(math.atan2(ax_g, math.sqrt(ay_g*ay_g + az_g*az_g + eps)))
    return theta_deg  # signed
"""

def compute_theta_extended(ax_g: float, ay_g: float, az_g: float, prev_theta):
    eps = 1e-12
    theta_raw = math.degrees(math.atan2(ax_g, math.sqrt(ay_g*ay_g + az_g*az_g + eps)))  # [-90, +90]

    # Zone ambiguë autour de az = 0
    if abs(az_g) < AZ_EPS and prev_theta is not None:
        return prev_theta

    # Extension à +/-180°
    if az_g < 0:
        return math.copysign(180.0 - abs(theta_raw), theta_raw)
    else:
        return theta_raw


def compute_psi_base(ax_g: float, ay_g: float, az_g: float) -> float:
    """
    Compute a psi candidate in degrees normalized to [0, 360).
    This mirrors the previous handling: when az < 0 a 180 - alpha adjustment
    was applied; we keep that for producing a base 0..360 candidate.
    """
    eps = 1e-12
    alpha_psi = math.degrees(math.atan2(ay_g, math.sqrt(ax_g*ax_g + az_g*az_g + eps)))
    if az_g < 0.0:
        psi = 180.0 - alpha_psi
    else:
        psi = alpha_psi
    return psi % 360.0

# ---------------- ASC3 parsing & accel reader ----------------
def parse_asc3_line(line: str) -> Optional[Tuple[int, int, int]]:
    parts = line.strip().split()
    if len(parts) < 5:
        return None
    if parts[0] != "ASC3":
        return None
    try:
        ax = int(parts[2])
        ay = int(parts[3])
        az = int(parts[4])
        return ax, ay, az
    except ValueError:
        return None

def accel_reader_thread(sock: socket.socket):
    """
    Read ASC3 frames and update:
      - latest_theta (signed)
      - latest_psi_unwrapped (continuous)
      - latest_accel_g, latest_raw_lsb, latest_raw_ts
    Unwrapping strategy for psi:
      - produce base candidates p1 = psi_base, p2 = (psi_base + 180) % 360
      - for each candidate, compute the unwrapped value closest to previous unwrapped psi
        by adding multiples of 360 (k*360).
      - pick the unwrapped candidate closest to previous unwrapped psi.
      - if no previous psi, pick p1 as initial (unwrapped = p1).
    This keeps psi continuous across ±180 illusions and allows psi to accumulate beyond 360°.
    """
    global latest_theta, latest_psi_unwrapped, latest_accel_g, latest_raw_lsb, latest_raw_ts
    buf = ""
    sock.settimeout(SOCKET_TIMEOUT)
    while running_event.is_set():
        try:
            data = sock.recv(4096)
            if not data:
                print("[AccelReader] remote closed")
                running_event.clear()
                break
            buf += data.decode(errors="ignore")
            lines = buf.split("\n")
            buf = lines[-1]
            for line in lines[:-1]:
                parsed = parse_asc3_line(line)
                if not parsed:
                    continue
                ax_lsb, ay_lsb, az_lsb = parsed
                ax_g, ay_g, az_g = lsb_to_g(ax_lsb, ay_lsb, az_lsb)

                #theta_signed = compute_theta_signed(ax_g, ay_g, az_g)

                with accel_lock:
                    prev_theta = latest_theta

                theta_ext = compute_theta_extended(ax_g, ay_g, az_g, prev_theta)    

                psi_base = compute_psi_base(ax_g, ay_g, az_g)  # 0..360

                with accel_lock:
                    prev_unwrapped = latest_psi_unwrapped

                    # Build the two base candidates (because of 180° ambiguity when az flips)
                    candidates_base = [psi_base % 360.0, (psi_base + 180.0) % 360.0]

                    chosen_unwrapped = None
                    if prev_unwrapped is None:
                        # initialize using the first base candidate (prefer the one near 0..180)
                        # choose candidate with smaller absolute value after mapping to (-180,180]
                        # but simpler: pick candidates_base[0]
                        chosen_unwrapped = candidates_base[0]
                    else:
                        # For each base candidate, compute k to move it by k*360 so it is closest to prev_unwrapped
                        best_diff = None
                        for b in candidates_base:
                            k = round((prev_unwrapped - b) / 360.0)
                            unwrapped = b + 360.0 * k
                            diff = abs(unwrapped - prev_unwrapped)
                            if best_diff is None or diff < best_diff:
                                best_diff = diff
                                chosen_unwrapped = unwrapped

                    # Update shared state
                    #latest_theta = theta_signed
                    latest_theta = theta_ext
                    latest_psi_unwrapped = chosen_unwrapped
                    latest_accel_g = (ax_g, ay_g, az_g)
                    latest_raw_lsb = (ax_lsb, ay_lsb, az_lsb)
                    latest_raw_ts = _now_iso()
        except socket.timeout:
            continue
        except Exception as e:
            print(f"[AccelReader] error: {e}")
            time.sleep(0.05)

# ---------------- Settling wait ----------------
def wait_for_settle(timeout: float = SETTLE_TIMEOUT,
                    stable_duration: float = STABLE_DURATION,
                    tol: float = STABLE_TOL) -> bool:
    t_start = time.time()
    stable_start: Optional[float] = None
    last_norm: Optional[float] = None
    while running_event.is_set():
        with accel_lock:
            accel = latest_accel_g
        if accel is None:
            if time.time() - t_start > timeout:
                return False
            time.sleep(CONTROL_PERIOD)
            continue

        norm = math.sqrt(accel[0]**2 + accel[1]**2 + accel[2]**2)
        if last_norm is None or abs(norm - last_norm) <= tol:
            if stable_start is None:
                stable_start = time.time()
            elif time.time() - stable_start >= stable_duration:
                return True
        else:
            stable_start = None
        last_norm = norm

        if time.time() - t_start > timeout:
            return False
        time.sleep(CONTROL_PERIOD)
    return False

# ---------------- Motor helpers ----------------
def send_command(ser_obj, cmd: str):
    try:
        out = (cmd + "\n").encode()
        ser_obj.write(out)
        if hasattr(ser_obj, "flush"):
            try:
                ser_obj.flush()
            except Exception:
                pass
    except Exception as e:
        print(f"[send_command] {e} cmd={cmd}")

def stop_all(ser_obj):
    send_command(ser_obj, "?stopall")

class SerialStub:
    def write(self, b):
        s = b.decode() if isinstance(b, (bytes, bytearray)) else str(b)
        s = s.strip()
        print(f"[SerialStub] -> {s}")
    def flush(self):
        pass
    def close(self):
        pass

def build_serial_obj(serial_port: str = SERIAL_PORT, baud: int = BAUDRATE):
    try:
        import serial  # type: ignore
        ser = serial.Serial(serial_port, baud, timeout=1.0)
        time.sleep(0.1)
        print(f"[Main] opened serial {serial_port} @ {baud}")
        return ser
    except Exception as e:
        print(f"[Main] Could not open serial port {serial_port}: {e}")
        print("[Main] falling back to SerialStub (no motor control will occur)")
        return SerialStub()

# ---------------- Control routines (theta non-circular) ----------------
def move_theta(target: float, ser_obj, theta_cmd_holder: dict):
    """
    Move theta with coarse open-loop timing followed by fine correction using accel feedback.
    target is in degrees and should be in the approximate domain [-90, +90].
    theta_cmd_holder['theta_cmd'] holds the last commanded theta in the same signed convention.
    """
    print(f"\n→ move_theta: target={target:.1f}° (cmd was {theta_cmd_holder['theta_cmd']:.1f}°)")
    # Use plain signed difference for theta (non-circular)
    delta_cmd = target - theta_cmd_holder["theta_cmd"]
    if abs(delta_cmd) < 0.1:
        print("  already at commanded theta")
        return

    direction = 1 if delta_cmd > 0 else -1
    abs_delta = abs(delta_cmd)
    t_est = abs_delta / max(OMEGA_EST, 1e-6)
    t_coarse = min(t_est * 1.1, 90.0)

    # Open-loop coarse move
    send_command(ser_obj, f"?m1={direction * MOTOR_SPEED}")
    t0 = time.time()
    stopped = False

    while running_event.is_set() and (time.time() - t0) < t_coarse * 2.0:
        with accel_lock:
            th = latest_theta
        if th is not None:
            err = target - th  # signed direct error
            if abs(err) < 3.0:
                stop_all(ser_obj)
                stopped = True
                break
        time.sleep(CONTROL_PERIOD)

    if not stopped:
        stop_all(ser_obj)

    # Fine correction if accel reliable
    with accel_lock:
        accel = latest_accel_g
    reliable = accel is not None and (ACCEL_NORM_MIN <= math.sqrt(accel[0]**2 + accel[1]**2 + accel[2]**2) <= ACCEL_NORM_MAX)
    if not reliable:
        print("  accel unreliable for fine correction -> accept coarse result")
        theta_cmd_holder["theta_cmd"] = target
        time.sleep(0.5)
        return

    fine_start = time.time()
    fine_timeout = 30.0
    while running_event.is_set() and (time.time() - fine_start) < fine_timeout:
        with accel_lock:
            th = latest_theta
        if th is None:
            print("  lost accel during fine correction")
            break
        err = target - th
        if abs(err) <= ANGLE_TOL:
            break
        cmd = KP_FINE * err
        cmd = max(min(cmd, MOTOR_SPEED), -MOTOR_SPEED)
        send_command(ser_obj, f"?m1={int(round(cmd))}")
        time.sleep(CONTROL_PERIOD)

    stop_all(ser_obj)
    theta_cmd_holder["theta_cmd"] = target
    wait_for_settle(timeout=2.0, stable_duration=0.4, tol=STABLE_TOL)
    print(f"  theta_cmd updated -> {theta_cmd_holder['theta_cmd']:.1f}°")

# ---------------- PSI sweep (records unwrapped psi) ----------------
def sweep_psi_stepwise(direction: int, theta_deg: float, ser_obj, dataset: List[List]):
    """
    Stepwise psi sweep: for N_PSI_STEPS:
      - open-loop motor2 command for estimated t_step
      - stop and wait for settling
      - log the measured (unwrapped) psi and theta
    """
    print(f"→ sweep_psi_stepwise {'CW' if direction>0 else 'CCW'} at theta_cmd {theta_deg:.1f}°")
    t_step = PSI_STEP / max(OMEGA_EST, 1e-6)
    t_step = min(t_step, 60.0)

    for k in range(N_PSI_STEPS):
        if not running_event.is_set():
            break
        send_command(ser_obj, f"?m2={direction * MOTOR_SPEED}")
        time.sleep(t_step)
        stop_all(ser_obj)

        stable = wait_for_settle(timeout=SETTLE_TIMEOUT, stable_duration=STABLE_DURATION, tol=STABLE_TOL)
        with accel_lock:
            psi_unwrapped = latest_psi_unwrapped
            theta_meas = latest_theta
            accel = latest_accel_g
            raw = latest_raw_lsb
            raw_ts = latest_raw_ts

        log_time = raw_ts if raw_ts is not None else _now_iso()

        if not stable:
            print(f"  Step {k+1}: warning - accel did not settle in time")
        if psi_unwrapped is None or theta_meas is None or raw is None:
            print(f"  Step {k+1}: missing accel data, recording partial")
            dataset.append([log_time, theta_deg, theta_meas, psi_unwrapped, None, None, None])
        else:
            normg = math.sqrt(accel[0]**2 + accel[1]**2 + accel[2]**2)
            dataset.append([log_time, theta_deg, theta_meas, psi_unwrapped, raw[0], raw[1], raw[2], normg])
            print(f"  Step {k+1}/{N_PSI_STEPS} | Psi_unwrapped={psi_unwrapped:.1f}° | Theta_meas={theta_meas:.1f}° | |g|={normg:.3f}")

    print("→ psi sweep done\n")

# ---------------- Dataset IO ----------------
def save_dataset_csv(dataset: List[List], prefix: str = "scan_dataset") -> Optional[str]:
    if not dataset:
        print("[I/O] dataset empty, nothing to save")
        return None
    fname = f"{prefix}_{int(time.time())}.csv"
    try:
        with open(fname, "w", newline="") as f:
            writer = csv.writer(f)
            writer.writerow(["time_utc", "theta_cmd_deg", "theta_meas_deg", "psi_unwrapped_deg", "x_lsb", "y_lsb", "z_lsb", "norm_g"])
            writer.writerows(dataset)
        print(f"[I/O] dataset saved to {fname}")
        return fname
    except Exception as e:
        print(f"[I/O] could not save dataset: {e}")
        return None

# ---------------- Top-level custom sequence ----------------
def run_scan_sequence(host: str, port: int, ser_obj):
    running_event.set()
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    try:
        print(f"[Main] connecting to accel {host}:{port} ...")
        sock.connect((host, port))
    except Exception as e:
        print(f"[Main] accel connect error: {e}")
        running_event.clear()
        return

    reader = threading.Thread(target=accel_reader_thread, args=(sock,), daemon=True)
    reader.start()

    theta_cmd_holder = {"theta_cmd": 0.0}
    dataset: List[List] = []
    saved_fname: Optional[str] = None

    try:
        stop_all(ser_obj)
        time.sleep(0.1)

        sequence = [
            {"theta": 0.0,   "psi_sweep": False, "psi_dir": 1},
            {"theta": 90.0,  "psi_sweep": False, "psi_dir": 1},
            {"theta": 60.0,  "psi_sweep": True,  "psi_dir": 1},
            {"theta": 30.0,  "psi_sweep": True,  "psi_dir": -1},
            {"theta": 0.0,   "psi_sweep": True,  "psi_dir": 1},
            {"theta": -30.0, "psi_sweep": True,  "psi_dir": -1},
            {"theta": -60.0, "psi_sweep": True,  "psi_dir": 1},
            {"theta": -90.0, "psi_sweep": False, "psi_dir": 1},
            {"theta": 0.0,   "psi_sweep": False, "psi_dir": 1},
        ]

        for idx, step in enumerate(sequence):
            target_theta = step["theta"]
            psi_sweep = step["psi_sweep"]
            psi_dir = step["psi_dir"]

            print(f"\n=== Step {idx+1}/{len(sequence)}: Move theta={target_theta}°, sweep psi={psi_sweep} ===")
            # Move theta (signed, non-circular)
            move_theta(target_theta, ser_obj, theta_cmd_holder)

            if psi_sweep:
                sweep_psi_stepwise(psi_dir, target_theta, ser_obj, dataset)
            else:
                stable = wait_for_settle(timeout=SETTLE_TIMEOUT, stable_duration=STABLE_DURATION, tol=STABLE_TOL)
                with accel_lock:
                    theta_meas = latest_theta
                    psi_unwrapped = latest_psi_unwrapped
                    accel = latest_accel_g
                    raw = latest_raw_lsb
                    raw_ts = latest_raw_ts

                log_time = raw_ts if raw_ts is not None else _now_iso()
                if accel is not None and theta_meas is not None and psi_unwrapped is not None and raw is not None:
                    normg = math.sqrt(accel[0]**2 + accel[1]**2 + accel[2]**2)
                    dataset.append([log_time, target_theta, theta_meas, psi_unwrapped, raw[0], raw[1], raw[2], normg])
                    print(f"  Recorded | Theta={theta_meas:.1f}°, Psi_unwrapped={psi_unwrapped:.1f}°, |g|={normg:.3f}")
                else:
                    print("  Warning: missing accelerometer data for logging")

        print("\n[Main] Custom sequence complete")
        saved_fname = save_dataset_csv(dataset, prefix="scan_dataset")

    except KeyboardInterrupt:
        print("[Main] interrupted by user — saving partial dataset")
        saved_fname = save_dataset_csv(dataset, prefix="partial_scan")
    except Exception as e:
        print(f"[Main] unexpected error: {e} — saving partial dataset")
        saved_fname = save_dataset_csv(dataset, prefix="error_scan")
        raise
    finally:
        running_event.clear()
        stop_all(ser_obj)
        time.sleep(0.05)
        try:
            sock.close()
        except Exception:
            pass
        if hasattr(ser_obj, "close"):
            try:
                ser_obj.close()
            except Exception:
                pass
        reader.join(timeout=1.0)
        print("[Main] shutdown")
        if saved_fname:
            print(f"[Main] dataset file: {saved_fname}")

# ---------------- CLI ----------------
def parse_args():
    p = argparse.ArgumentParser(description="Accelerometer pilot (theta [-90,90], psi unwrapped)")
    p.add_argument("--host", default=HOST, help="Accelerometer host")
    p.add_argument("--port", type=int, default=PORT, help="Accelerometer port")
    p.add_argument("--serial", default=SERIAL_PORT, help="Serial port for motor controller")
    p.add_argument("--baud", type=int, default=BAUDRATE, help="Serial baudrate")
    return p.parse_args()

def main():
    args = parse_args()
    ser_obj = build_serial_obj(args.serial, args.baud)
    try:
        run_scan_sequence(args.host, args.port, ser_obj)
    except Exception as e:
        print(f"[Main] fatal: {e}")
    finally:
        if hasattr(ser_obj, "close"):
            try:
                ser_obj.close()
            except Exception:
                pass

if __name__ == "__main__":
    main()