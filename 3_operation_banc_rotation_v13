#!/usr/bin/env python3
"""
Accelerometer calibration bench pilot - Zigzag Version (Dynamic Step)
Modifications:
 - Ajout d'une saisie utilisateur pour le pas de Psi
 - Validation que le pas est un diviseur de 360
"""

import argparse
import json
import csv
import math
import socket
import threading
import time
from datetime import datetime
from typing import List, Optional, Tuple

# ---------------- Config ----------------
HOST = "192.168.4.1"
PORT = 3535
SERIAL_PORT = "COM7"
BAUDRATE = 115200

SENSITIVITY = 256000.0  # LSB/g
MOTOR_SPEED = 30
OMEGA_EST = 8.04  # deg/s @ MOTOR_SPEED
KP_FINE = 2.0
ANGLE_TOL = 1.0
CONTROL_PERIOD = 0.05
SETTLE_TIMEOUT = 8.0
STABLE_DURATION = 1.5
STABLE_TOL = 0.008
SOCKET_TIMEOUT = 1.0

# ---------------- Shared state ----------------
accel_lock = threading.Lock()
latest_theta: Optional[float] = None
latest_psi_unwrapped: Optional[float] = None
latest_accel_g: Optional[Tuple[float, float, float]] = None
latest_raw_lsb: Optional[Tuple[int, int, int]] = None
latest_raw_ts: Optional[str] = None
running_event = threading.Event()

# ---------------- Utilities ----------------
def _now_iso() -> str:
    return datetime.utcnow().isoformat(timespec="microseconds") + "Z"

def lsb_to_g(ax_lsb: int, ay_lsb: int, az_lsb: int) -> Tuple[float, float, float]:
    return ax_lsb / SENSITIVITY, ay_lsb / SENSITIVITY, az_lsb / SENSITIVITY

def compute_theta_signed(ax_g: float, ay_g: float, az_g: float) -> float:
    eps = 1e-12
    return math.degrees(math.atan2(ax_g, math.sqrt(ay_g*ay_g + az_g*az_g + eps)))

def compute_psi_signed(ax_g: float, ay_g: float, az_g: float) -> float:
    """Psi réel moteur [-180,180]"""
    return math.degrees(math.atan2(ay_g, az_g))

def normalize_angle(angle: float) -> float:
    return (angle + 180.0) % 360.0 - 180.0

def parse_asc3_line(line: str) -> Optional[Tuple[int, int, int]]:
    parts = line.strip().split()
    if len(parts) < 5 or parts[0] != "ASC3": return None
    try: return int(parts[2]), int(parts[3]), int(parts[4])
    except ValueError: return None

import json

def load_calibration_sequence(path: str) -> list:
    """Charge la liste des couples (theta, psi) depuis le JSON."""
    try:
        with open(path, "r") as f:
            cfg = json.load(f)
        points = cfg.get("sequence")
        if not points:
            raise ValueError("La clé 'sequence' est absente ou vide.")
        print(f"Séquence chargée : {len(points)} points de mesure.")
        return points
    except Exception as e:
        print(f"Erreur chargement JSON: {e}")
        raise

def accel_reader_thread(sock: socket.socket):
    global latest_theta, latest_psi_unwrapped, latest_accel_g, latest_raw_lsb, latest_raw_ts

    buf = ""
    sock.settimeout(SOCKET_TIMEOUT)

    while running_event.is_set():
        try:
            data = sock.recv(4096)
            if not data:
                break

            buf += data.decode(errors="ignore")
            lines = buf.split("\n")
            buf = lines[-1]

            for line in lines[:-1]:
                parsed = parse_asc3_line(line)
                if not parsed:
                    continue

                ax_lsb, ay_lsb, az_lsb = parsed
                ax_g, ay_g, az_g = lsb_to_g(ax_lsb, ay_lsb, az_lsb)

                # Theta inchangé
                theta_signed = compute_theta_signed(ax_g, ay_g, az_g)

                psi_signed = math.degrees(math.atan2(ay_g, az_g))
                psi_signed = (psi_signed + 180.0) % 360.0 - 180.0

                with accel_lock:
                    prev = latest_psi_unwrapped

                    if prev is None:
                        psi_unwrapped = psi_signed
                    else:
                        k = round((prev - psi_signed) / 360.0)
                        psi_unwrapped = psi_signed + 360.0 * k

                    latest_theta = theta_signed
                    latest_psi_unwrapped = psi_unwrapped
                    latest_accel_g = (ax_g, ay_g, az_g)
                    latest_raw_lsb = (ax_lsb, ay_lsb, az_lsb)
                    latest_raw_ts = _now_iso()

        except socket.timeout:
            continue
        except Exception as e:
            print(f"[AccelReader] error: {e}")
            time.sleep(0.05)

def wait_for_settle(timeout: float = SETTLE_TIMEOUT, stable_duration: float = STABLE_DURATION, tol: float = STABLE_TOL) -> bool:
    t_start = time.time()
    stable_start: Optional[float] = None
    last_norm: Optional[float] = None
    while running_event.is_set():
        with accel_lock:
            accel = latest_accel_g
        if accel is None:
            if time.time() - t_start > timeout: return False
            time.sleep(CONTROL_PERIOD)
            continue
        norm = math.sqrt(accel[0]**2 + accel[1]**2 + accel[2]**2)
        if last_norm is None or abs(norm - last_norm) <= tol:
            if stable_start is None: stable_start = time.time()
            elif time.time() - stable_start >= stable_duration: return True
        else: stable_start = None
        last_norm = norm
        if time.time() - t_start > timeout: return False
        time.sleep(CONTROL_PERIOD)
    return False

# ---------------- Motor helpers ----------------
def send_command(ser_obj, cmd: str):
    try:
        ser_obj.write((cmd + "\n").encode())
        if hasattr(ser_obj, "flush"): ser_obj.flush()
    except Exception as e: print(f"[send_command] {e} cmd={cmd}")

def stop_all(ser_obj):
    send_command(ser_obj, "?stopall")

class SerialStub:
    def write(self, b): print(f"[SerialStub] -> {b.decode().strip()}")
    def flush(self): pass
    def close(self): pass

def build_serial_obj(serial_port: str, baud: int):
    try:
        import serial
        return serial.Serial(serial_port, baud, timeout=1.0)
    except Exception:
        return SerialStub()

# ---------------- Control routines ----------------

def move_theta(target: float, ser_obj, theta_cmd_holder: dict):
    print(f"\n→ move_theta: {target:.1f}°")
    with accel_lock:
        current_theta = latest_theta if latest_theta is not None else theta_cmd_holder["theta_cmd"]
    delta = target - current_theta
    if abs(delta) < 0.2: return
    direction = 1 if delta > 0 else -1
    t_coarse = min(abs(delta) / max(OMEGA_EST, 1e-6) * 1.1, 90.0)
    send_command(ser_obj, f"?m1={direction * MOTOR_SPEED}")
    t0 = time.time()
    while running_event.is_set() and (time.time() - t0) < t_coarse:
        with accel_lock:
            th = latest_theta
        if th is not None and abs(target - th) < 3.0: break
        time.sleep(CONTROL_PERIOD)
    stop_all(ser_obj)
    fine_start = time.time()
    while running_event.is_set() and (time.time() - fine_start) < 15.0:
        with accel_lock:
            th = latest_theta
        if th is None or abs(target - th) <= ANGLE_TOL: break
        cmd = max(min(KP_FINE * (target - th), MOTOR_SPEED), -MOTOR_SPEED)
        send_command(ser_obj, f"?m1={int(round(cmd))}")
        time.sleep(CONTROL_PERIOD)
    stop_all(ser_obj)
    theta_cmd_holder["theta_cmd"] = target
    wait_for_settle(timeout=2.0, stable_duration=0.5)

def move_psi_incremental(target_psi_cmd, psi_cmd_holder, ser_obj):
    current_cmd = psi_cmd_holder["psi_cmd"]
    delta = target_psi_cmd - current_cmd

    if abs(delta) < 0.5:
        return

    print(f"→ move_psi_incremental: Δψ = {delta:.1f}°")

    direction = 1 if delta > 0 else -1
    t_move = abs(delta) / max(OMEGA_EST, 1e-6)

    send_command(ser_obj, f"?m2={direction * MOTOR_SPEED}")
    time.sleep(t_move)
    stop_all(ser_obj)

    psi_cmd_holder["psi_cmd"] = target_psi_cmd
    wait_for_settle(timeout=4.0, stable_duration=0.8)

# ---------------- Main Logic ----------------
def run_scan_sequence(host: str, port: int, ser_obj):
    psi_cmd = 0.0  # position moteur estimée (commande interne)

    # 1. Charger la séquence complète
    sequence = load_calibration_sequence("psi_steps.json")

    running_event.set()
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    try:
        sock.connect((host, port))
    except Exception as e:
        print(f"Connect error: {e}"); return

    reader = threading.Thread(target=accel_reader_thread, args=(sock,), daemon=True)
    reader.start()

    theta_cmd_holder = {"theta_cmd": 0.0}
    psi_cmd_holder = {"psi_cmd": 0.0}
    dataset = []

    try:
        stop_all(ser_obj)
        last_theta = None

        for idx, point in enumerate(sequence):
            target_theta = point["theta"]
            target_psi = point["psi"]

            print(f"[{idx+1}/{len(sequence)}] Target: Theta={target_theta}°, Psi={target_psi}°")

            # Déplacement Theta (seulement s'il change)
            if last_theta is None or abs(target_theta - last_theta) > 0.1:
                move_theta(target_theta, ser_obj, theta_cmd_holder)
                last_theta = target_theta

            move_psi_incremental(target_psi, psi_cmd_holder, ser_obj)

            # Attente de stabilisation et capture
            if wait_for_settle():
                with accel_lock:
                    if latest_accel_g:
                        ax, ay, az = latest_accel_g
                        normg = math.sqrt(ax**2 + ay**2 + az**2)
                        dataset.append([
                            latest_raw_ts or _now_iso(), 
                            target_theta, 
                            latest_theta, 
                            latest_psi_unwrapped, 
                            latest_raw_lsb[0], 
                            latest_raw_lsb[1], 
                            latest_raw_lsb[2], 
                            normg
                        ])
                        print(f"   -> Enregistré: G={normg:.4f}")
            else:
                print(f"   !! Timeout stabilisation à {target_theta}/{target_psi}")

        # Sauvegarde CSV
        fname = f"scan_full_{int(time.time())}.csv"
        # ... (ton code de sauvegarde CSV actuel) ...

    finally:
        running_event.clear()
        stop_all(ser_obj)
        sock.close()
        reader.join(1.0)

if __name__ == "__main__":
    ser = build_serial_obj(SERIAL_PORT, BAUDRATE)
    run_scan_sequence(HOST, PORT, ser)