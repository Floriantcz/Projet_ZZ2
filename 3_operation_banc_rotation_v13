#!/usr/bin/env python3
"""
Accelerometer calibration bench pilot - Dynamic Config & Closed Loop Version
Correction : Retour Ã  0Â° asservi en boucle fermÃ©e pour Ã©viter les rotations infinies.
AmÃ©lioration : gestion fiable de psi_unwrapped pendant les zigzags.
"""

import json
import csv
import math
import socket
import threading
import time
import os
from datetime import datetime
from typing import List, Optional, Tuple

# ---------------- Config ----------------
HOST = "192.168.4.1"
PORT = 3535
SERIAL_PORT = "COM7"
BAUDRATE = 115200

SENSITIVITY = 256000.0  # LSB/g
MOTOR_SPEED_MAX = 30
MOTOR_SPEED_MIN = 15
KP_PSI = 2.5
KP_THETA = 2.0
ANGLE_TOL = 0.9         # STOP_THRESHOLD
CONTROL_PERIOD = 0.05
SETTLE_TIMEOUT = 8.0
STABLE_DURATION = 1.5
STABLE_TOL = 0.008
SOCKET_TIMEOUT = 1.0

# ---------------- Shared state ----------------
accel_lock = threading.Lock()
latest_theta: Optional[float] = None
latest_psi_unwrapped: Optional[float] = None
latest_psi_signed: Optional[float] = None
latest_accel_g: Optional[Tuple[float, float, float]] = None
latest_raw_lsb: Optional[Tuple[int, int, int]] = None
latest_raw_ts: Optional[str] = None
running_event = threading.Event()

# ---------------- Utilities ----------------
def _now_iso() -> str:
    return datetime.utcnow().isoformat(timespec="microseconds") + "Z"

def lsb_to_g(ax_lsb: int, ay_lsb: int, az_lsb: int) -> Tuple[float, float, float]:
    return ax_lsb / SENSITIVITY, ay_lsb / SENSITIVITY, az_lsb / SENSITIVITY

def compute_theta_signed(ax_g: float, ay_g: float, az_g: float) -> float:
    eps = 1e-12
    return math.degrees(math.atan2(ax_g, math.sqrt(ay_g*ay_g + az_g*az_g + eps)))

def normalize_angle(angle: float) -> float:
    """RamÃ¨ne l'angle dans [-180, 180]"""
    return (angle + 180.0) % 360.0 - 180.0

def parse_asc3_line(line: str) -> Optional[Tuple[int, int, int]]:
    parts = line.strip().split()
    if len(parts) < 5 or parts[0] != "ASC3": return None
    try: return int(parts[2]), int(parts[3]), int(parts[4])
    except ValueError: return None

def load_config(path: str) -> list:
    if not os.path.exists(path):
        raise FileNotFoundError(f"Fichier config introuvable : {path}")
    with open(path, "r") as f:
        cfg = json.load(f)
    sequence = cfg.get("sequence", [])
    if not sequence:
        raise ValueError("La clÃ© 'sequence' est absente ou vide.")
    return sequence

# ---------------- Threads ----------------
def accel_reader_thread(sock: socket.socket):
    global latest_theta, latest_psi_unwrapped, latest_psi_signed, latest_accel_g, latest_raw_lsb, latest_raw_ts
    buf = ""
    sock.settimeout(SOCKET_TIMEOUT)
    while running_event.is_set():
        try:
            data = sock.recv(4096)
            if not data: break
            buf += data.decode(errors="ignore")
            lines = buf.split("\n")
            buf = lines[-1]
            for line in lines[:-1]:
                parsed = parse_asc3_line(line)
                if not parsed: continue
                ax_lsb, ay_lsb, az_lsb = parsed
                ax_g, ay_g, az_g = lsb_to_g(ax_lsb, ay_lsb, az_lsb)
                
                theta = compute_theta_signed(ax_g, ay_g, az_g)
                psi_s = math.degrees(math.atan2(ay_g, az_g))
                psi_s = normalize_angle(psi_s)

                with accel_lock:
                    prev = latest_psi_unwrapped
                    if prev is None:
                        psi_unwrapped = psi_s
                    else:
                        k = round((prev - psi_s) / 360.0)
                        psi_unwrapped = psi_s + 360.0 * k
                    
                    latest_theta = theta
                    latest_psi_signed = psi_s
                    latest_psi_unwrapped = psi_unwrapped
                    latest_accel_g = (ax_g, ay_g, az_g)
                    latest_raw_lsb = (ax_lsb, ay_lsb, az_lsb)
                    latest_raw_ts = _now_iso()
        except: continue

# ---------------- Wait/Settle ----------------
def wait_for_settle(timeout=SETTLE_TIMEOUT):
    t_start = time.time()
    stable_start = None
    last_norm = None
    while running_event.is_set():
        with accel_lock: accel = latest_accel_g
        if accel is None:
            if time.time() - t_start > timeout: return False
            time.sleep(CONTROL_PERIOD); continue
        norm = math.sqrt(sum(x**2 for x in accel))
        if last_norm is None or abs(norm - last_norm) <= STABLE_TOL:
            if stable_start is None: stable_start = time.time()
            elif time.time() - stable_start >= STABLE_DURATION: return True
        else: stable_start = None
        last_norm = norm
        if time.time() - t_start > timeout: return False
        time.sleep(CONTROL_PERIOD)
    return False

# ---------------- Motor Control ----------------
def send_command(ser_obj, cmd: str):
    try:
        ser_obj.write((cmd + "\n").encode())
    except: pass

def stop_all(ser_obj):
    send_command(ser_obj, "?stopall")

def move_psi_closed_loop(target_psi: float, ser_obj, use_unwrapped=False):
    print(f"â†’ move_psi: targeting {target_psi:.2f}Â°")
    t0 = time.time()
    while running_event.is_set():
        with accel_lock:
            current = latest_psi_unwrapped if use_unwrapped else latest_psi_signed
        if current is None:
            time.sleep(CONTROL_PERIOD); continue

        error = target_psi - current
        if not use_unwrapped: error = normalize_angle(error)

        if abs(error) < ANGLE_TOL:
            stop_all(ser_obj)
            break

        speed = KP_PSI * error
        speed = max(min(speed, MOTOR_SPEED_MAX), -MOTOR_SPEED_MAX)
        if abs(speed) < MOTOR_SPEED_MIN: speed = math.copysign(MOTOR_SPEED_MIN, speed)

        send_command(ser_obj, f"?m2={int(speed)}")

        if time.time() - t0 > 30.0:
            stop_all(ser_obj)
            break
        time.sleep(CONTROL_PERIOD)
    stop_all(ser_obj)

def move_theta_closed_loop(target_theta: float, ser_obj):
    print(f"â†’ move_theta: targeting {target_theta:.2f}Â°")
    t0 = time.time()
    local_speed_max = MOTOR_SPEED_MAX
    if abs(target_theta) > 80: local_speed_max = 20

    while running_event.is_set():
        with accel_lock: current = latest_theta
        if current is None: time.sleep(CONTROL_PERIOD); continue

        error = target_theta - current
        if abs(target_theta) >= 89.0 and abs(current) >= 88.5:
            if abs(error) < 1.0:
                stop_all(ser_obj)
                break

        if abs(error) < ANGLE_TOL:
            stop_all(ser_obj)
            break

        speed = KP_THETA * error
        speed = max(min(speed, local_speed_max), -local_speed_max)
        if abs(error) < 5 or abs(speed) < MOTOR_SPEED_MIN:
            speed = math.copysign(MOTOR_SPEED_MIN, speed)

        send_command(ser_obj, f"?m1={int(speed)}")

        if time.time() - t0 > 20.0: break
        time.sleep(CONTROL_PERIOD)
    stop_all(ser_obj)

# ---------------- Sweep Psi ----------------
def sweep_psi_variable(theta_deg, ser_obj, dataset, start_pos, psi_steps) -> float:
    """
    Zigzag de psi avec suivi fiable : on incrÃ©mente la position cumulÃ©e
    plutÃ´t que de se fier uniquement au capteur, pour Ã©viter dÃ©calage sur gros steps.
    """
    current_target = start_pos
    direction = -1 if start_pos > 0 else 1

    for step_deg in psi_steps:
        wait_for_settle()

        # Enregistrement des donnÃ©es
        with accel_lock:
            dataset.append([latest_raw_ts or _now_iso(), theta_deg, latest_theta,
                            latest_psi_unwrapped, latest_raw_lsb[0], latest_raw_lsb[1],
                            latest_raw_lsb[2], math.sqrt(sum(a*a for a in latest_accel_g))])
            print(f"   [Data] Psi={latest_psi_unwrapped:.1f}Â°")

        # Fractionner les gros steps pour Ã©viter saturation moteur
        sub_steps = max(1, int(abs(step_deg)/30))
        for sub in range(sub_steps):
            sub_target = current_target + direction * (step_deg/sub_steps)
            move_psi_closed_loop(sub_target, ser_obj, use_unwrapped=True)
            current_target = sub_target

    return current_target

# ---------------- Main Logic ----------------
def run_scan_sequence(host, port, ser_obj, config_path):
    try: sequence = load_config(config_path)
    except Exception as e: print(e); return

    running_event.set()
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    try: sock.connect((host, port))
    except: return

    threading.Thread(target=accel_reader_thread, args=(sock,), daemon=True).start()
    dataset = []
    current_psi_unwrapped = 180.0 

    try:
        stop_all(ser_obj)
        for idx, step in enumerate(sequence):
            target_theta = float(step.get("theta", 0.0))
            psi_steps = step.get("psi_steps", [])

            print(f"\n=== STEP {idx+1}/{len(sequence)}: Theta {target_theta}Â° ===")
            
            move_theta_closed_loop(target_theta, ser_obj)

            # ðŸ”¹ Correction : recalibrage du point de dÃ©part psi aprÃ¨s move_theta
            with accel_lock:
                if latest_psi_unwrapped is not None:
                    current_psi_unwrapped = latest_psi_unwrapped

            if idx == 0:
                move_psi_closed_loop(180.0, ser_obj, use_unwrapped=False)

            if psi_steps:
                current_psi_unwrapped = sweep_psi_variable(target_theta, ser_obj, dataset, current_psi_unwrapped, psi_steps)
            else:
                wait_for_settle()
                with accel_lock:
                    if latest_accel_g:
                        normg = math.sqrt(sum(x*x for x in latest_accel_g))
                        dataset.append([latest_raw_ts or _now_iso(), target_theta, latest_theta,
                                        latest_psi_unwrapped, latest_raw_lsb[0], latest_raw_lsb[1],
                                        latest_raw_lsb[2], normg])
                        print(f"   [Data Stat] Psi={latest_psi_unwrapped:.1f}Â°")

        print("\n=== FIN : Retour Physique Ã  0Â° (Asservi) ===")
        move_psi_closed_loop(0.0, ser_obj, use_unwrapped=False)
        move_theta_closed_loop(0.0, ser_obj)
        
        fname = f"scan_{os.path.splitext(config_path)[0]}_{int(time.time())}.csv"
        with open(fname, "w", newline="") as f:
            writer = csv.writer(f)
            writer.writerow(["time_utc","theta_cmd_deg","theta_meas_deg","psi_unwrapped_deg",
                             "x_lsb","y_lsb","z_lsb","norm_g"])
            writer.writerows(dataset)

    finally:
        running_event.clear()
        stop_all(ser_obj)
        sock.close()

# ---------------- Serial ----------------
def build_serial_obj(port, baud):
    import serial
    return serial.Serial(port, baud, timeout=1)

# ---------------- Main ----------------
if __name__ == "__main__":
    CONFIGS = {"1": "config_standard.json", "2": "config_rapide.json", "3": "config_lent.json"}
    print("1: Standard | 2: Rapide | 3: Lent")
    choix = input("Choix : ").strip()
    if choix in CONFIGS:
        try:
            ser = build_serial_obj(SERIAL_PORT, BAUDRATE)
            run_scan_sequence(HOST, PORT, ser, CONFIGS[choix])
        except Exception as e:
            print(f"Erreur lors de l'exÃ©cution : {e}")
    else:
        print("Choix invalide. Fin du programme.")
