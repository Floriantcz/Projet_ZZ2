#!/usr/bin/env python3

import json
import csv
import math
import socket
import threading
import time
from datetime import datetime
from typing import Optional, Tuple

# ---------------- CONFIG ----------------
HOST = "192.168.4.1"
PORT = 3535
SERIAL_PORT = "COM3"
BAUDRATE = 115200

SENSITIVITY = 256000.0  # LSB / g

KP = 2.5
MAX_SPEED = 30
MIN_SPEED = 15

STOP_THRESHOLD = 0.9
CONTROL_PERIOD = 0.05
SETTLE_TIME = 1.0
TIMEOUT = 30

THETA_SAFE = 85.0
PSI_SAFE = 179.0   # ne jamais atteindre ±180°

# ---------------- SHARED STATE ----------------
accel_lock = threading.Lock()
latest_theta: Optional[float] = None
latest_psi: Optional[float] = None
latest_raw: Optional[Tuple[int, int, int]] = None
latest_ts: Optional[str] = None
running = True

# ---------------- UTILS ----------------
def now():
    return datetime.utcnow().isoformat(timespec="milliseconds") + "Z"

def normalize_angle(a):
    return (a + 180) % 360 - 180

def shortest_angle_error(target, current):
    return (target - current + 180) % 360 - 180

def clamp(v, vmin, vmax):
    return max(min(v, vmax), vmin)

# ---------------- ACCEL ----------------
def lsb_to_g(ax, ay, az):
    return ax / SENSITIVITY, ay / SENSITIVITY, az / SENSITIVITY

def compute_angles(ax, ay, az):
    eps = 1e-12
    theta = math.degrees(math.atan2(ax, math.sqrt(ay * ay + az * az + eps)))
    psi = math.degrees(math.atan2(ay, az))
    theta = clamp(theta, -90, 90)
    psi = normalize_angle(psi)
    return theta, psi

def parse_asc3(line):
    p = line.strip().split()
    if len(p) >= 5 and p[0] == "ASC3":
        try:
            return int(p[2]), int(p[3]), int(p[4])
        except:
            pass
    return None

def accel_reader(sock):
    global latest_theta, latest_psi, latest_raw, latest_ts
    buf = ""
    sock.settimeout(1)

    while running:
        try:
            data = sock.recv(4096).decode(errors="ignore")
            buf += data
            lines = buf.split("\n")
            buf = lines[-1]

            for line in lines[:-1]:
                r = parse_asc3(line)
                if not r:
                    continue

                ax_g, ay_g, az_g = lsb_to_g(*r)
                theta, psi = compute_angles(ax_g, ay_g, az_g)

                with accel_lock:
                    latest_theta = theta
                    latest_psi = psi
                    latest_raw = r
                    latest_ts = now()
        except:
            pass

# ---------------- MOTOR ----------------
def send(ser, cmd):
    ser.write((cmd + "\n").encode())

def stop_all(ser):
    send(ser, "?stopall")

def move_motor(target, get_angle, motor_id, name, amin, amax, ser):
    target = clamp(target, amin, amax)
    start = time.time()

    print(f"→ {name} cible : {target:+.1f}°")

    while running:
        with accel_lock:
            current = get_angle()

        if current is None:
            time.sleep(CONTROL_PERIOD)
            continue

        current = normalize_angle(current)
        error = shortest_angle_error(target, current)

        print(f"   {name} = {current:+6.2f}° | erreur = {error:+6.2f}°")

        if abs(error) < STOP_THRESHOLD:
            stop_all(ser)
            print(f"✓ {name} atteint")
            break

        speed = KP * error
        speed = clamp(speed, -MAX_SPEED, MAX_SPEED)

        if abs(speed) < MIN_SPEED:
            speed = math.copysign(MIN_SPEED, speed)

        send(ser, f"?m{motor_id}={int(speed)}")

        if time.time() - start > TIMEOUT:
            stop_all(ser)
            raise RuntimeError(f"{name} timeout")

        time.sleep(CONTROL_PERIOD)

    time.sleep(SETTLE_TIME)

# ---------------- SCAN LOGIC ----------------
def sweep_psi(theta_cmd, psi_positions, ser, dataset):
    print(f"  ↪ Balayage Psi (Theta = {theta_cmd:+.1f}°)")

    for idx, psi_target in enumerate(psi_positions, 1):
        psi_target = clamp(psi_target, -PSI_SAFE, PSI_SAFE)
        print(f"    → Psi position {idx}/{len(psi_positions)} : {psi_target:+.1f}°")

        move_motor(psi_target, lambda: latest_psi, 2, "Psi", -PSI_SAFE, PSI_SAFE, ser)

        with accel_lock:
            if latest_raw:
                ax, ay, az = latest_raw
                norm = math.sqrt(sum((v / SENSITIVITY) ** 2 for v in latest_raw))

                print(
                    f"      [MESURE] θ={latest_theta:+6.2f}° | "
                    f"ψ={latest_psi:+7.2f}° | |g|={norm:.3f}"
                )

                dataset.append([latest_ts, theta_cmd, latest_theta, latest_psi, ax, ay, az, norm])

# ---------------- MAIN SEQUENCE ----------------
def run_sequence(config_path, ser):
    with open(config_path) as f:
        sequence = json.load(f)["sequence"]

    dataset = []

    print("\n=== INITIALISATION ===")
    print("→ Positionnement initial Psi = +180°")
    move_motor(180, lambda: latest_psi, 2, "Psi", -PSI_SAFE, PSI_SAFE, ser)

    for step_idx, step in enumerate(sequence, 1):
        theta_cmd = step["theta"]

        # Sécurité : jamais atteindre ±90°
        if theta_cmd >= 90:
            theta_cmd = 88
        elif theta_cmd <= -90:
            theta_cmd = -88

        psi_positions = step.get("psi_positions", [])

        print(f"\n=== ÉTAPE {step_idx}/{len(sequence)} ===")
        move_motor(theta_cmd, lambda: latest_theta, 1, "Theta", -THETA_SAFE, THETA_SAFE, ser)

        if psi_positions:
            sweep_psi(theta_cmd, psi_positions, ser, dataset)
        else:
            print("  (Pas de balayage Psi)")
            time.sleep(SETTLE_TIME)

    print("\n=== FIN DU SCAN ===")
    print("→ Retour Psi = 0°, Theta = 0°")

    move_motor(0, lambda: latest_psi, 2, "Psi", -PSI_SAFE, PSI_SAFE, ser)
    move_motor(0, lambda: latest_theta, 1, "Theta", -THETA_SAFE, THETA_SAFE, ser)

    with open("scan_result.csv", "w", newline="") as f:
        writer = csv.writer(f)
        writer.writerow(["time", "theta_cmd", "theta", "psi", "x", "y", "z", "norm"])
        writer.writerows(dataset)

    print("Scan terminé – CSV sauvegardé.")

# ---------------- PROGRAM ENTRY ----------------
if __name__ == "__main__":
    import serial

    print("\nChoisir le mode de scan :")
    print("  1 → Standard")
    print("  2 → Rapide")
    print("  3 → Lent")

    choice = input("Votre choix [1/2/3] : ").strip()

    CONFIG_MAP = {
        "1": ("STANDARD", "config_standard.json"),
        "2": ("RAPIDE",   "config_rapide.json"),
        "3": ("LENT",     "config_lent.json")
    }

    if choice not in CONFIG_MAP:
        print("Choix invalide, mode STANDARD utilisé.")
        mode_name, config_file = CONFIG_MAP["1"]
    else:
        mode_name, config_file = CONFIG_MAP[choice]

    print(f"\nMode sélectionné : {mode_name}")
    print(f"Configuration : {config_file}\n")

    print("Connexion à l'accéléromètre…")
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.connect((HOST, PORT))
    print("Accéléromètre connecté")

    print("Connexion au contrôleur moteur…")
    ser = serial.Serial(SERIAL_PORT, BAUDRATE, timeout=1)
    time.sleep(2)
    print("Moteurs connectés")

    threading.Thread(target=accel_reader, args=(sock,), daemon=True).start()

    try:
        run_sequence(config_file, ser)
    finally:
        running = False
        stop_all(ser)
        ser.close()
        sock.close()