#!/usr/bin/env python3
"""
Accelerometer calibration bench pilot - Zigzag Version (Dynamic Step)
Modifications:
 - Ajout d'une saisie utilisateur pour le pas de Psi
 - Validation que le pas est un diviseur de 360
"""

import argparse
import csv
import math
import socket
import threading
import time
from datetime import datetime
from typing import List, Optional, Tuple

# ---------------- Config ----------------
HOST = "192.168.4.1"
PORT = 3535
SERIAL_PORT = "COM7"
BAUDRATE = 115200

SENSITIVITY = 256000.0  # LSB/g
MOTOR_SPEED = 30
OMEGA_EST = 8.04  # deg/s @ MOTOR_SPEED
KP_FINE = 2.0
ANGLE_TOL = 1.0
CONTROL_PERIOD = 0.05
SETTLE_TIMEOUT = 8.0
STABLE_DURATION = 1.5
STABLE_TOL = 0.008
SOCKET_TIMEOUT = 1.0

# ---------------- Shared state ----------------
accel_lock = threading.Lock()
latest_theta: Optional[float] = None
latest_psi_unwrapped: Optional[float] = None
latest_accel_g: Optional[Tuple[float, float, float]] = None
latest_raw_lsb: Optional[Tuple[int, int, int]] = None
latest_raw_ts: Optional[str] = None
running_event = threading.Event()

# ---------------- Utilities ----------------
def _now_iso() -> str:
    return datetime.utcnow().isoformat(timespec="microseconds") + "Z"

def get_valid_step() -> float:
    """Demande à l'utilisateur un pas et vérifie s'il est diviseur de 360."""
    while True:
        try:
            val_str = input("\nEntrez le pas souhaité pour Psi en degrés (ex: 10, 30, 45) : ")
            val = float(val_str)
            if val <= 0:
                print("Le pas doit être un nombre positif.")
                continue
            
            # Vérification si c'est un diviseur de 360
            # On utilise modulo sur le résultat de la division pour gérer les flottants (ex: 22.5)
            if (360.0 / val).is_integer():
                print(f"Pas de {val}° validé ({(360/val):.0f} paliers par tour).")
                return val
            else:
                print(f"Erreur : {val} n'est pas un diviseur de 360. Veuillez réessayer.")
        except ValueError:
            print("Entrée invalide. Veuillez saisir un nombre.")

def lsb_to_g(ax_lsb: int, ay_lsb: int, az_lsb: int) -> Tuple[float, float, float]:
    return ax_lsb / SENSITIVITY, ay_lsb / SENSITIVITY, az_lsb / SENSITIVITY

def compute_theta_signed(ax_g: float, ay_g: float, az_g: float) -> float:
    eps = 1e-12
    return math.degrees(math.atan2(ax_g, math.sqrt(ay_g*ay_g + az_g*az_g + eps)))

def compute_psi_base(ax_g: float, ay_g: float, az_g: float) -> float:
    eps = 1e-12
    alpha_psi = math.degrees(math.atan2(ay_g, math.sqrt(ax_g*ax_g + az_g*az_g + eps)))
    if az_g < 0.0:
        psi = 180.0 - alpha_psi
    else:
        psi = alpha_psi
    return psi % 360.0

def parse_asc3_line(line: str) -> Optional[Tuple[int, int, int]]:
    parts = line.strip().split()
    if len(parts) < 5 or parts[0] != "ASC3": return None
    try: return int(parts[2]), int(parts[3]), int(parts[4])
    except ValueError: return None

def accel_reader_thread(sock: socket.socket):
    global latest_theta, latest_psi_unwrapped, latest_accel_g, latest_raw_lsb, latest_raw_ts
    buf = ""
    sock.settimeout(SOCKET_TIMEOUT)
    while running_event.is_set():
        try:
            data = sock.recv(4096)
            if not data: break
            buf += data.decode(errors="ignore")
            lines = buf.split("\n")
            buf = lines[-1]
            for line in lines[:-1]:
                parsed = parse_asc3_line(line)
                if not parsed: continue
                ax_lsb, ay_lsb, az_lsb = parsed
                ax_g, ay_g, az_g = lsb_to_g(ax_lsb, ay_lsb, az_lsb)
                theta_signed = compute_theta_signed(ax_g, ay_g, az_g)
                psi_base = compute_psi_base(ax_g, ay_g, az_g)
                with accel_lock:
                    prev_unwrapped = latest_psi_unwrapped
                    if prev_unwrapped is None: chosen_unwrapped = psi_base
                    else:
                        k = round((prev_unwrapped - psi_base) / 360.0)
                        chosen_unwrapped = psi_base + 360.0 * k
                    latest_theta = theta_signed
                    latest_psi_unwrapped = chosen_unwrapped
                    latest_accel_g = (ax_g, ay_g, az_g)
                    latest_raw_lsb = (ax_lsb, ay_lsb, az_lsb)
                    latest_raw_ts = _now_iso()
        except socket.timeout: continue
        except Exception as e:
            print(f"[AccelReader] error: {e}")
            time.sleep(0.05)

def wait_for_settle(timeout: float = SETTLE_TIMEOUT, stable_duration: float = STABLE_DURATION, tol: float = STABLE_TOL) -> bool:
    t_start = time.time()
    stable_start: Optional[float] = None
    last_norm: Optional[float] = None
    while running_event.is_set():
        with accel_lock:
            accel = latest_accel_g
        if accel is None:
            if time.time() - t_start > timeout: return False
            time.sleep(CONTROL_PERIOD)
            continue
        norm = math.sqrt(accel[0]**2 + accel[1]**2 + accel[2]**2)
        if last_norm is None or abs(norm - last_norm) <= tol:
            if stable_start is None: stable_start = time.time()
            elif time.time() - stable_start >= stable_duration: return True
        else: stable_start = None
        last_norm = norm
        if time.time() - t_start > timeout: return False
        time.sleep(CONTROL_PERIOD)
    return False

# ---------------- Motor helpers ----------------
def send_command(ser_obj, cmd: str):
    try:
        ser_obj.write((cmd + "\n").encode())
        if hasattr(ser_obj, "flush"): ser_obj.flush()
    except Exception as e: print(f"[send_command] {e} cmd={cmd}")

def stop_all(ser_obj):
    send_command(ser_obj, "?stopall")

class SerialStub:
    def write(self, b): print(f"[SerialStub] -> {b.decode().strip()}")
    def flush(self): pass
    def close(self): pass

def build_serial_obj(serial_port: str, baud: int):
    try:
        import serial
        return serial.Serial(serial_port, baud, timeout=1.0)
    except Exception:
        return SerialStub()

# ---------------- Control routines ----------------

def move_theta(target: float, ser_obj, theta_cmd_holder: dict):
    print(f"\n→ move_theta: {target:.1f}°")
    with accel_lock:
        current_theta = latest_theta if latest_theta is not None else theta_cmd_holder["theta_cmd"]
    delta = target - current_theta
    if abs(delta) < 0.2: return
    direction = 1 if delta > 0 else -1
    t_coarse = min(abs(delta) / max(OMEGA_EST, 1e-6) * 1.1, 90.0)
    send_command(ser_obj, f"?m1={direction * MOTOR_SPEED}")
    t0 = time.time()
    while running_event.is_set() and (time.time() - t0) < t_coarse:
        with accel_lock:
            th = latest_theta
        if th is not None and abs(target - th) < 3.0: break
        time.sleep(CONTROL_PERIOD)
    stop_all(ser_obj)
    fine_start = time.time()
    while running_event.is_set() and (time.time() - fine_start) < 15.0:
        with accel_lock:
            th = latest_theta
        if th is None or abs(target - th) <= ANGLE_TOL: break
        cmd = max(min(KP_FINE * (target - th), MOTOR_SPEED), -MOTOR_SPEED)
        send_command(ser_obj, f"?m1={int(round(cmd))}")
        time.sleep(CONTROL_PERIOD)
    stop_all(ser_obj)
    theta_cmd_holder["theta_cmd"] = target
    wait_for_settle(timeout=2.0, stable_duration=0.5)

def move_psi_direct(target: float, ser_obj):
    with accel_lock:
        current = latest_psi_unwrapped if latest_psi_unwrapped is not None else 0.0
    delta = target - current
    if abs(delta) < 1.0: return
    print(f"→ move_psi_direct: to {target:.1f}°")
    direction = 1 if delta > 0 else -1
    t_move = abs(delta) / max(OMEGA_EST, 1e-6)
    send_command(ser_obj, f"?m2={direction * MOTOR_SPEED}")
    time.sleep(t_move)
    stop_all(ser_obj)
    wait_for_settle(timeout=4.0, stable_duration=0.8)

def sweep_psi_zigzag(theta_deg: float, ser_obj, dataset: List[List], start_pos: float, step_deg: float) -> float:
    target_end = -180.0 if start_pos > 0 else 180.0
    direction = -1 if target_end < start_pos else 1
    
    print(f"→ sweep_psi_zigzag: Theta={theta_deg}°, Sweep {start_pos}° to {target_end}° (Step={step_deg}°)")
    
    current_target = start_pos
    num_steps = int(360 / step_deg)
    
    for i in range(num_steps + 1):
        wait_for_settle(timeout=SETTLE_TIMEOUT, stable_duration=STABLE_DURATION, tol=STABLE_TOL)
        with accel_lock:
            psi_meas, theta_meas, accel, raw, ts = latest_psi_unwrapped, latest_theta, latest_accel_g, latest_raw_lsb, latest_raw_ts
        
        if accel and raw:
            normg = math.sqrt(accel[0]**2 + accel[1]**2 + accel[2]**2)
            dataset.append([ts or _now_iso(), theta_deg, theta_meas, psi_meas, raw[0], raw[1], raw[2], normg])
            print(f"   [Data] Psi={psi_meas:.1f}°")

        if i < num_steps:
            current_target += direction * step_deg
            t_step = step_deg / max(OMEGA_EST, 1e-6)
            send_command(ser_obj, f"?m2={direction * MOTOR_SPEED}")
            time.sleep(t_step)
            stop_all(ser_obj)

    return target_end

# ---------------- Main Logic ----------------
def run_scan_sequence(host: str, port: int, ser_obj):
    # --- Nouveau : Récupération du pas avant de commencer ---
    psi_step = get_valid_step()

    running_event.set()
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    try:
        sock.connect((host, port))
    except Exception as e:
        print(f"Connect error: {e}"); return

    reader = threading.Thread(target=accel_reader_thread, args=(sock,), daemon=True)
    reader.start()

    theta_cmd_holder = {"theta_cmd": 0.0}
    dataset = []
    current_psi_side = 180.0 

    try:
        stop_all(ser_obj)
        sequence = [
            {"theta": 0.0,   "psi_sweep": False},
            {"theta": 90.0,  "psi_sweep": False},
            {"theta": 60.0,  "psi_sweep": True},
            {"theta": 30.0,  "psi_sweep": True},
            {"theta": 0.0,   "psi_sweep": True},
            {"theta": -30.0, "psi_sweep": True},
            {"theta": -60.0, "psi_sweep": True},
            {"theta": -90.0, "psi_sweep": False},
            {"theta": 0.0,   "psi_sweep": False},
        ]

        for idx, step in enumerate(sequence):
            target_theta = step["theta"]
            print(f"\n=== STEP {idx+1}/{len(sequence)}: Theta {target_theta}° ===")
            
            move_theta(target_theta, ser_obj, theta_cmd_holder)

            if idx == 0:
                print("Initial positioning to +180°...")
                move_psi_direct(180.0, ser_obj)

            if step["psi_sweep"]:
                # Utilisation du pas saisi par l'utilisateur
                current_psi_side = sweep_psi_zigzag(target_theta, ser_obj, dataset, current_psi_side, step_deg=psi_step)
            else:
                wait_for_settle()
                with accel_lock:
                    if latest_accel_g:
                        normg = math.sqrt(sum(x**2 for x in latest_accel_g))
                        dataset.append([latest_raw_ts or _now_iso(), target_theta, latest_theta, latest_psi_unwrapped, 
                                        latest_raw_lsb[0], latest_raw_lsb[1], latest_raw_lsb[2], normg])
                        print(f"   [Data Stat] Psi={latest_psi_unwrapped:.1f}°")

        print("\n=== FINAL POSITIONING: Return Psi to 0° ===")
        move_psi_direct(0.0, ser_obj)
        
        fname = f"scan_zigzag_{int(time.time())}.csv"
        with open(fname, "w", newline="") as f:
            writer = csv.writer(f)
            writer.writerow(["time_utc","theta_cmd_deg","theta_meas_deg","psi_unwrapped_deg","x_lsb","y_lsb","z_lsb","norm_g"])
            writer.writerows(dataset)
        print(f"Done. Saved to {fname}")

    finally:
        running_event.clear()
        stop_all(ser_obj)
        sock.close()
        reader.join(1.0)

if __name__ == "__main__":
    ser = build_serial_obj(SERIAL_PORT, BAUDRATE)
    run_scan_sequence(HOST, PORT, ser)