#!/usr/bin/env python3
"""
Accelerometer calibration bench pilot (theta limited to [-90, +90], continuous/unwrapped psi)

Modifications:
 - Theta stays signed in [-90, +90]
 - Psi is continuous (unwrapped) and now sweeps in 180° round-trips instead of full 360° stepwise
"""

import argparse
import csv
import math
import socket
import threading
import time
from datetime import datetime
from typing import List, Optional, Tuple

# ---------------- Config ----------------
HOST = "192.168.4.1"
PORT = 3535

SERIAL_PORT = "COM7"
BAUDRATE = 115200

SENSITIVITY = 256000.0  # LSB/g

MOTOR_SPEED = 30
OMEGA_EST = 8.04  # deg/s @ MOTOR_SPEED (calibrate)

KP_FINE = 2.0
ANGLE_TOL = 1.0  # deg

CONTROL_PERIOD = 0.05

# Settling parameters
SETTLE_TIMEOUT = 8.0
STABLE_DURATION = 1.5
STABLE_TOL = 0.008

ACCEL_NORM_MIN = 0.7
ACCEL_NORM_MAX = 1.3

SOCKET_TIMEOUT = 1.0

# ---------------- Shared state ----------------
accel_lock = threading.Lock()
latest_theta: Optional[float] = None
latest_psi_unwrapped: Optional[float] = None
latest_accel_g: Optional[Tuple[float, float, float]] = None
latest_raw_lsb: Optional[Tuple[int, int, int]] = None
latest_raw_ts: Optional[str] = None

running_event = threading.Event()

# ---------------- Utilities ----------------
def _now_iso() -> str:
    return datetime.utcnow().isoformat(timespec="microseconds") + "Z"

def lsb_to_g(ax_lsb: int, ay_lsb: int, az_lsb: int) -> Tuple[float, float, float]:
    return ax_lsb / SENSITIVITY, ay_lsb / SENSITIVITY, az_lsb / SENSITIVITY

def circular_distance(a: float, b: float) -> float:
    return abs((a - b + 180.0) % 360.0 - 180.0)

# ---------------- Angle computation ----------------
def compute_theta_signed(ax_g: float, ay_g: float, az_g: float) -> float:
    eps = 1e-12
    return math.degrees(math.atan2(ax_g, math.sqrt(ay_g*ay_g + az_g*az_g + eps)))

def compute_psi_base(ax_g: float, ay_g: float, az_g: float) -> float:
    eps = 1e-12
    alpha_psi = math.degrees(math.atan2(ay_g, math.sqrt(ax_g*ax_g + az_g*az_g + eps)))
    if az_g < 0.0:
        psi = 180.0 - alpha_psi
    else:
        psi = alpha_psi
    return psi % 360.0

# ---------------- ASC3 parsing ----------------
def parse_asc3_line(line: str) -> Optional[Tuple[int, int, int]]:
    parts = line.strip().split()
    if len(parts) < 5 or parts[0] != "ASC3":
        return None
    try:
        ax = int(parts[2])
        ay = int(parts[3])
        az = int(parts[4])
        return ax, ay, az
    except ValueError:
        return None

def accel_reader_thread(sock: socket.socket):
    global latest_theta, latest_psi_unwrapped, latest_accel_g, latest_raw_lsb, latest_raw_ts
    buf = ""
    sock.settimeout(SOCKET_TIMEOUT)
    while running_event.is_set():
        try:
            data = sock.recv(4096)
            if not data:
                print("[AccelReader] remote closed")
                running_event.clear()
                break
            buf += data.decode(errors="ignore")
            lines = buf.split("\n")
            buf = lines[-1]
            for line in lines[:-1]:
                parsed = parse_asc3_line(line)
                if not parsed:
                    continue
                ax_lsb, ay_lsb, az_lsb = parsed
                ax_g, ay_g, az_g = lsb_to_g(ax_lsb, ay_lsb, az_lsb)

                theta_signed = compute_theta_signed(ax_g, ay_g, az_g)
                psi_base = compute_psi_base(ax_g, ay_g, az_g)

                with accel_lock:
                    prev_unwrapped = latest_psi_unwrapped
                    candidates_base = [psi_base % 360.0, (psi_base + 180.0) % 360.0]

                    if prev_unwrapped is None:
                        chosen_unwrapped = candidates_base[0]
                    else:
                        best_diff = None
                        for b in candidates_base:
                            k = round((prev_unwrapped - b) / 360.0)
                            unwrapped = b + 360.0 * k
                            diff = abs(unwrapped - prev_unwrapped)
                            if best_diff is None or diff < best_diff:
                                best_diff = diff
                                chosen_unwrapped = unwrapped

                    latest_theta = theta_signed
                    latest_psi_unwrapped = chosen_unwrapped
                    latest_accel_g = (ax_g, ay_g, az_g)
                    latest_raw_lsb = (ax_lsb, ay_lsb, az_lsb)
                    latest_raw_ts = _now_iso()
        except socket.timeout:
            continue
        except Exception as e:
            print(f"[AccelReader] error: {e}")
            time.sleep(0.05)

# ---------------- Settling wait ----------------
def wait_for_settle(timeout: float = SETTLE_TIMEOUT,
                    stable_duration: float = STABLE_DURATION,
                    tol: float = STABLE_TOL) -> bool:
    t_start = time.time()
    stable_start: Optional[float] = None
    last_norm: Optional[float] = None
    while running_event.is_set():
        with accel_lock:
            accel = latest_accel_g
        if accel is None:
            if time.time() - t_start > timeout:
                return False
            time.sleep(CONTROL_PERIOD)
            continue

        norm = math.sqrt(accel[0]**2 + accel[1]**2 + accel[2]**2)
        if last_norm is None or abs(norm - last_norm) <= tol:
            if stable_start is None:
                stable_start = time.time()
            elif time.time() - stable_start >= stable_duration:
                return True
        else:
            stable_start = None
        last_norm = norm

        if time.time() - t_start > timeout:
            return False
        time.sleep(CONTROL_PERIOD)
    return False

# ---------------- Motor helpers ----------------
def send_command(ser_obj, cmd: str):
    try:
        out = (cmd + "\n").encode()
        ser_obj.write(out)
        if hasattr(ser_obj, "flush"):
            try:
                ser_obj.flush()
            except Exception:
                pass
    except Exception as e:
        print(f"[send_command] {e} cmd={cmd}")

def stop_all(ser_obj):
    send_command(ser_obj, "?stopall")

class SerialStub:
    def write(self, b):
        s = b.decode() if isinstance(b, (bytes, bytearray)) else str(b)
        print(f"[SerialStub] -> {s}")
    def flush(self):
        pass
    def close(self):
        pass

def build_serial_obj(serial_port: str = SERIAL_PORT, baud: int = BAUDRATE):
    try:
        import serial  # type: ignore
        ser = serial.Serial(serial_port, baud, timeout=1.0)
        time.sleep(0.1)
        print(f"[Main] opened serial {serial_port} @ {baud}")
        return ser
    except Exception as e:
        print(f"[Main] Could not open serial port {serial_port}: {e}")
        print("[Main] falling back to SerialStub")
        return SerialStub()

# ---------------- Control routines ----------------
def move_theta(target: float, ser_obj, theta_cmd_holder: dict):
    print(f"\n→ move_theta: target={target:.1f}° (cmd was {theta_cmd_holder['theta_cmd']:.1f}°)")
    delta_cmd = target - theta_cmd_holder["theta_cmd"]
    if abs(delta_cmd) < 0.1:
        print("  already at commanded theta")
        return

    direction = 1 if delta_cmd > 0 else -1
    abs_delta = abs(delta_cmd)
    t_est = abs_delta / max(OMEGA_EST, 1e-6)
    t_coarse = min(t_est * 1.1, 90.0)

    send_command(ser_obj, f"?m1={direction * MOTOR_SPEED}")
    t0 = time.time()
    stopped = False

    while running_event.is_set() and (time.time() - t0) < t_coarse * 2.0:
        with accel_lock:
            th = latest_theta
        if th is not None:
            err = target - th
            if abs(err) < 3.0:
                stop_all(ser_obj)
                stopped = True
                break
        time.sleep(CONTROL_PERIOD)

    if not stopped:
        stop_all(ser_obj)

    with accel_lock:
        accel = latest_accel_g
    reliable = accel is not None and (ACCEL_NORM_MIN <= math.sqrt(accel[0]**2 + accel[1]**2 + accel[2]**2) <= ACCEL_NORM_MAX)
    if not reliable:
        print("  accel unreliable for fine correction -> accept coarse result")
        theta_cmd_holder["theta_cmd"] = target
        time.sleep(0.5)
        return

    fine_start = time.time()
    fine_timeout = 30.0
    while running_event.is_set() and (time.time() - fine_start) < fine_timeout:
        with accel_lock:
            th = latest_theta
        if th is None:
            print("  lost accel during fine correction")
            break
        err = target - th
        if abs(err) <= ANGLE_TOL:
            break
        cmd = KP_FINE * err
        cmd = max(min(cmd, MOTOR_SPEED), -MOTOR_SPEED)
        send_command(ser_obj, f"?m1={int(round(cmd))}")
        time.sleep(CONTROL_PERIOD)

    stop_all(ser_obj)
    theta_cmd_holder["theta_cmd"] = target
    wait_for_settle(timeout=2.0, stable_duration=0.4, tol=STABLE_TOL)
    print(f"  theta_cmd updated -> {theta_cmd_holder['theta_cmd']:.1f}°")

# ---------------- PSI sweep (round-trip 180°) ----------------
def sweep_psi_roundtrip(theta_deg: float, ser_obj, dataset: List[List]):
    print(f"→ sweep_psi_roundtrip at theta_cmd {theta_deg:.1f}°")

    with accel_lock:
        psi_start = latest_psi_unwrapped
    if psi_start is None:
        print("  Warning: cannot sweep psi, initial psi unknown")
        return

    sweep_steps = [
        {"dir": 1, "angle": 180},
        {"dir": -1, "angle": 180}
    ]

    for step_idx, step in enumerate(sweep_steps):
        direction = step["dir"]
        angle = step["angle"]
        t_move = min(angle / max(OMEGA_EST, 1e-6), 60.0)

        send_command(ser_obj, f"?m2={direction * MOTOR_SPEED}")
        time.sleep(t_move)
        stop_all(ser_obj)
        wait_for_settle(timeout=SETTLE_TIMEOUT, stable_duration=STABLE_DURATION, tol=STABLE_TOL)

        # Record at max rotation
        with accel_lock:
            psi_unwrapped = latest_psi_unwrapped
            theta_meas = latest_theta
            accel = latest_accel_g
            raw = latest_raw_lsb
            raw_ts = latest_raw_ts
        log_time = raw_ts if raw_ts else _now_iso()
        if psi_unwrapped is not None and theta_meas is not None and accel is not None and raw is not None:
            normg = math.sqrt(accel[0]**2 + accel[1]**2 + accel[2]**2)
            dataset.append([log_time, theta_deg, theta_meas, psi_unwrapped, raw[0], raw[1], raw[2], normg])
            print(f"  Step {step_idx+1} | Psi_unwrapped={psi_unwrapped:.1f}° | Theta_meas={theta_meas:.1f}° | |g|={normg:.3f}")
        else:
            print(f"  Step {step_idx+1} | missing accel data")

        # Return to start
        send_command(ser_obj, f"?m2={-direction * MOTOR_SPEED}")
        time.sleep(t_move)
        stop_all(ser_obj)
        wait_for_settle(timeout=SETTLE_TIMEOUT, stable_duration=STABLE_DURATION, tol=STABLE_TOL)

        with accel_lock:
            psi_unwrapped = latest_psi_unwrapped
            theta_meas = latest_theta
            accel = latest_accel_g
            raw = latest_raw_lsb
            raw_ts = latest_raw_ts
        log_time = raw_ts if raw_ts else _now_iso()
        if psi_unwrapped is not None and theta_meas is not None and accel is not None and raw is not None:
            normg = math.sqrt(accel[0]**2 + accel[1]**2 + accel[2]**2)
            dataset.append([log_time, theta_deg, theta_meas, psi_unwrapped, raw[0], raw[1], raw[2], normg])
            print(f"  Step {step_idx+1} return | Psi_unwrapped={psi_unwrapped:.1f}° | Theta_meas={theta_meas:.1f}° | |g|={normg:.3f}")
        else:
            print(f"  Step {step_idx+1} return | missing accel data")

    print("→ psi round-trip sweep done\n")

# ---------------- Dataset IO ----------------
def save_dataset_csv(dataset: List[List], prefix: str = "scan_dataset") -> Optional[str]:
    if not dataset:
        print("[I/O] dataset empty, nothing to save")
        return None
    fname = f"{prefix}_{int(time.time())}.csv"
    try:
        with open(fname, "w", newline="") as f:
            writer = csv.writer(f)
            writer.writerow(["time_utc", "theta_cmd_deg", "theta_meas_deg", "psi_unwrapped_deg",
                             "x_lsb", "y_lsb", "z_lsb", "norm_g"])
            writer.writerows(dataset)
        print(f"[I/O] dataset saved to {fname}")
        return fname
    except Exception as e:
        print(f"[I/O] could not save dataset: {e}")
        return None

# ---------------- Top-level sequence ----------------
def run_scan_sequence(host: str, port: int, ser_obj):
    running_event.set()
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    try:
        print(f"[Main] connecting to accel {host}:{port} ...")
        sock.connect((host, port))
    except Exception as e:
        print(f"[Main] accel connect error: {e}")
        running_event.clear()
        return

    reader = threading.Thread(target=accel_reader_thread, args=(sock,), daemon=True)
    reader.start()

    theta_cmd_holder = {"theta_cmd": 0.0}
    dataset: List[List] = []
    saved_fname: Optional[str] = None

    try:
        stop_all(ser_obj)
        time.sleep(0.1)

        sequence = [
            {"theta": 0.0,   "psi_sweep": False},
            {"theta": 90.0,  "psi_sweep": False},
            {"theta": 60.0,  "psi_sweep": True},
            {"theta": 30.0,  "psi_sweep": True},
            {"theta": 0.0,   "psi_sweep": True},
            {"theta": -30.0, "psi_sweep": True},
            {"theta": -60.0, "psi_sweep": True},
            {"theta": -90.0, "psi_sweep": False},
            {"theta": 0.0,   "psi_sweep": False},
        ]

        for idx, step in enumerate(sequence):
            target_theta = step["theta"]
            psi_sweep = step["psi_sweep"]

            print(f"\n=== Step {idx+1}/{len(sequence)}: Move theta={target_theta}°, sweep psi={psi_sweep} ===")
            move_theta(target_theta, ser_obj, theta_cmd_holder)

            if psi_sweep:
                sweep_psi_roundtrip(target_theta, ser_obj, dataset)
            else:
                stable = wait_for_settle(timeout=SETTLE_TIMEOUT, stable_duration=STABLE_DURATION, tol=STABLE_TOL)
                with accel_lock:
                    theta_meas = latest_theta
                    psi_unwrapped = latest_psi_unwrapped
                    accel = latest_accel_g
                    raw = latest_raw_lsb
                    raw_ts = latest_raw_ts

                log_time = raw_ts if raw_ts else _now_iso()
                if accel and theta_meas is not None and psi_unwrapped is not None and raw is not None:
                    normg = math.sqrt(accel[0]**2 + accel[1]**2 + accel[2]**2)
                    dataset.append([log_time, target_theta, theta_meas, psi_unwrapped,
                                    raw[0], raw[1], raw[2], normg])
                    print(f"  Recorded | Theta={theta_meas:.1f}°, Psi_unwrapped={psi_unwrapped:.1f}°, |g|={normg:.3f}")
                else:
                    print("  Warning: missing accelerometer data for logging")

        print("\n[Main] Custom sequence complete")
        saved_fname = save_dataset_csv(dataset, prefix="scan_dataset")

    except KeyboardInterrupt:
        print("[Main] interrupted by user — saving partial dataset")
        saved_fname = save_dataset_csv(dataset, prefix="partial_scan")
    except Exception as e:
        print(f"[Main] unexpected error: {e} — saving partial dataset")
        saved_fname = save_dataset_csv(dataset, prefix="error_scan")
        raise
    finally:
        running_event.clear()
        stop_all(ser_obj)
        time.sleep(0.05)
        try:
            sock.close()
        except Exception:
            pass
        if hasattr(ser_obj, "close"):
            try:
                ser_obj.close()
            except Exception:
                pass
        reader.join(timeout=1.0)
        print("[Main] shutdown")
        if saved_fname:
            print(f"[Main] dataset file: {saved_fname}")

# ---------------- CLI ----------------
def parse_args():
    p = argparse.ArgumentParser(description="Accelerometer pilot (theta [-90,90], psi unwrapped, round-trip sweep)")
    p.add_argument("--host", default=HOST, help="Accelerometer host")
    p.add_argument("--port", type=int, default=PORT, help="Accelerometer port")
    p.add_argument("--serial", default=SERIAL_PORT, help="Serial port for motor controller")
    p.add_argument("--baud", type=int, default=BAUDRATE, help="Serial baudrate")
    return p.parse_args()

def main():
    args = parse_args()
    ser_obj = build_serial_obj(args.serial, args.baud)
    try:
        run_scan_sequence(args.host, args.port, ser_obj)
    except Exception as e:
        print(f"[Main] fatal: {e}")
    finally:
        if hasattr(ser_obj, "close"):
            try:
                ser_obj.close()
            except Exception:
                pass

if __name__ == "__main__":
    main()
