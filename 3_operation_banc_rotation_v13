#!/usr/bin/env python3
"""
Accelerometer calibration bench pilot
Version STABLE : intégration logique camarade + scan automatique
"""

import json, csv, math, socket, threading, time, os
from datetime import datetime
from typing import Optional, Tuple

# ---------------- CONFIG ----------------
HOST = "192.168.4.1"
PORT = 3535
SERIAL_PORT = "COM7"
BAUDRATE = 115200

SENSITIVITY = 256000.0

KP = 2.5
MAX_SPEED = 30
MIN_SPEED = 15

STOP_THRESHOLD = 0.9
CONTROL_PERIOD = 0.05
SETTLE_TIME = 1.0
TIMEOUT = 30

THETA_SAFE = 89.0
PSI_SAFE = 178.0   # JAMAIS ±180°

# ---------------- SHARED STATE ----------------
accel_lock = threading.Lock()
latest_theta: Optional[float] = None
latest_psi: Optional[float] = None
latest_raw: Optional[Tuple[int,int,int]] = None
latest_ts: Optional[str] = None
running = True

# ---------------- UTILS ----------------
def now():
    return datetime.utcnow().isoformat(timespec="milliseconds") + "Z"

def normalize_angle(a):
    return (a + 180) % 360 - 180

def shortest_angle_error(target, current):
    return (target - current + 180) % 360 - 180

def clamp(v, vmin, vmax):
    return max(min(v, vmax), vmin)

# ---------------- ACCEL ----------------
def lsb_to_g(ax, ay, az):
    return ax / SENSITIVITY, ay / SENSITIVITY, az / SENSITIVITY

def compute_angles(ax, ay, az):
    eps = 1e-12
    theta = math.degrees(math.atan2(ax, math.sqrt(ay*ay + az*az + eps)))
    psi   = math.degrees(math.atan2(ay, az))
    theta = clamp(theta, -90, 90)
    psi   = normalize_angle(psi)
    return theta, psi

def parse_asc3(line):
    p = line.strip().split()
    if len(p) >= 5 and p[0] == "ASC3":
        try:
            return int(p[2]), int(p[3]), int(p[4])
        except:
            pass
    return None

def accel_reader(sock):
    global latest_theta, latest_psi, latest_raw, latest_ts
    buf = ""
    sock.settimeout(1)
    while running:
        try:
            data = sock.recv(4096).decode(errors="ignore")
            buf += data
            lines = buf.split("\n")
            buf = lines[-1]
            for l in lines[:-1]:
                r = parse_asc3(l)
                if not r: continue
                ax, ay, az = lsb_to_g(*r)
                theta, psi = compute_angles(ax, ay, az)
                with accel_lock:
                    latest_theta = theta
                    latest_psi = psi
                    latest_raw = r
                    latest_ts = now()
        except:
            pass

# ---------------- MOTOR ----------------
def send(ser, cmd):
    ser.write((cmd + "\n").encode())

def stop_all(ser):
    send(ser, "?stopall")

def move_motor(target, get_angle, motor_id, name, amin, amax, ser):
    target = clamp(target, amin, amax)
    start = time.time()

    while running:
        with accel_lock:
            current = get_angle()

        if current is None:
            time.sleep(CONTROL_PERIOD)
            continue

        current = normalize_angle(current)
        error = shortest_angle_error(target, current)

        if abs(error) < STOP_THRESHOLD:
            stop_all(ser)
            break

        speed = KP * error
        speed = clamp(speed, -MAX_SPEED, MAX_SPEED)

        if abs(speed) < MIN_SPEED:
            speed = math.copysign(MIN_SPEED, speed)

        send(ser, f"?m{motor_id}={int(speed)}")

        if time.time() - start > TIMEOUT:
            stop_all(ser)
            raise RuntimeError(f"{name} timeout")

        time.sleep(CONTROL_PERIOD)

    time.sleep(SETTLE_TIME)

# ---------------- SCAN LOGIC ----------------
def sweep_psi(theta_cmd, psi_steps, ser, dataset):
    psi_target = 0.0

    for step in psi_steps:
        psi_target += step
        psi_target = clamp(psi_target, -PSI_SAFE, PSI_SAFE)

        move_motor(
            psi_target,
            lambda: latest_psi,
            2,
            "Psi",
            -PSI_SAFE,
            PSI_SAFE,
            ser
        )

        with accel_lock:
            if latest_raw:
                ax, ay, az = latest_raw
                norm = math.sqrt(sum((v/SENSITIVITY)**2 for v in latest_raw))
                dataset.append([
                    latest_ts, theta_cmd,
                    latest_theta, latest_psi,
                    ax, ay, az, norm
                ])

def run_sequence(config_path, ser):
    with open(config_path) as f:
        seq = json.load(f)["sequence"]

    dataset = []

    for step in seq:
        theta = clamp(step["theta"], -THETA_SAFE, THETA_SAFE)

        move_motor(
            theta,
            lambda: latest_theta,
            1,
            "Theta",
            -THETA_SAFE,
            THETA_SAFE,
            ser
        )

        if step["psi_steps"]:
            sweep_psi(theta, step["psi_steps"], ser, dataset)
        else:
            time.sleep(SETTLE_TIME)

    # retour zéro
    move_motor(0, lambda: latest_psi, 2, "Psi", -PSI_SAFE, PSI_SAFE, ser)
    move_motor(0, lambda: latest_theta, 1, "Theta", -THETA_SAFE, THETA_SAFE, ser)

    # save CSV
    with open("scan_result.csv", "w", newline="") as f:
        w = csv.writer(f)
        w.writerow(["time","theta_cmd","theta","psi","x","y","z","norm"])
        w.writerows(dataset)

# ---------------- MAIN ----------------
if __name__ == "__main__":
    import serial

    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.connect((HOST, PORT))

    ser = serial.Serial(SERIAL_PORT, BAUDRATE, timeout=1)
    time.sleep(2)

    threading.Thread(target=accel_reader, args=(sock,), daemon=True).start()

    try:
        run_sequence("config_standard.json", ser)
    finally:
        running = False
        stop_all(ser)
        ser.close()
        sock.close()
