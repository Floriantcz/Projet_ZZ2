import socket
import serial
import time
import math
import threading

# ------------------- CONFIG -----------------------
HOST = '192.168.4.1'
PORT = 3535

SERIAL_PORT = 'COM3'
BAUDRATE = 115200

SENSITIVITY = 256000.0  # LSB / g

KP = 2.5
MAX_SPEED = 30
MIN_SPEED = 15

STOP_THRESHOLD = 0.9   # deg
CONTROL_PERIOD = 0.05
SETTLE_TIME = 1.0
TIMEOUT = 30

# ------------------- SHARED STATE ----------------
accel_lock = threading.Lock()
latest_theta = None
latest_psi = None
running = True

# ------------------- HELPERS -------------------
def send_command(cmd):
    ser.write((cmd + "\n").encode())
    time.sleep(0.01)

def stop_all():
    send_command("?stopall")

def get_accel_lsb():
    """Lecture du capteur (ASC3 <timestamp> <x> <y> <z>)"""
    try:
        raw = sock.recv(1024).decode()
        lines = raw.split('\n')
        for line in lines:
            if line.startswith('ASC3'):
                parts = line.strip().split('\t')
                if len(parts) >= 5:
                    return int(parts[2]), int(parts[3]), int(parts[4])
    except:
        pass
    return None

def lsb_to_g(ax, ay, az):
    return ax / SENSITIVITY, ay / SENSITIVITY, az / SENSITIVITY

def compute_angles(ax, ay, az):
    """Theta [-90,90], Psi [-180,180]"""

    eps = 1e-12
    theta = math.degrees(math.atan2(ax, math.sqrt(ay*ay + az*az + eps)))
    psi = math.degrees(math.atan2(ay, az))  # [-180,180]

    return theta, psi

def normalize_angle(angle):
    """Normalise angle dans [-180,180]"""
    angle = (angle + 180) % 360 - 180
    return angle

# ------------------- ACCEL THREAD ----------------
def accel_reader():
    global latest_theta, latest_psi

    while running:
        data = get_accel_lsb()
        if data:
            ax_lsb, ay_lsb, az_lsb = data
            ax, ay, az = lsb_to_g(ax_lsb, ay_lsb, az_lsb)

            theta, psi = compute_angles(ax, ay, az)
            psi = normalize_angle(psi)
            with accel_lock:
                latest_theta = theta
                latest_psi = psi


# ------------------- CONTROL FUNCTION REVISEE --------------------

def move_motor_to_angle(target_angle, get_angle, motor_id, name, min_angle=None, max_angle=None):

    if min_angle is not None and max_angle is not None:
        target_angle = max(min(target_angle, max_angle), min_angle)

    print(f"\n--- Moving {name} to {target_angle:.2f}° ---")
    start_time = time.time()

    while True:
        with accel_lock:
            current_angle = get_angle()

        if current_angle is None:
            continue

        # Limiter la valeur mesurée si nécessaire
        if min_angle is not None and max_angle is not None:
            current_angle = max(min(current_angle, max_angle), min_angle)

        error = target_angle - current_angle
        print(f"{name} = {current_angle:+.2f}° | error = {error:+.2f}°")

        # Vérifier si on est à l'angle souhaité
        if abs(error) < STOP_THRESHOLD:
            stop_all()
            print(f"{name} target reached and stabilized.")
            break

        speed = KP * error
        speed = max(min(speed, MAX_SPEED), -MAX_SPEED)

        # Éviter que le moteur stagne
        if abs(speed) < MIN_SPEED:
            speed = math.copysign(MIN_SPEED, speed)

        send_command(f"?m{motor_id}={int(speed)}")

        # Timeout sécurité
        if time.time() - start_time > TIMEOUT:
            stop_all()
            raise RuntimeError(f"Timeout reaching {name}")

        time.sleep(CONTROL_PERIOD)

    time.sleep(SETTLE_TIME)

# ------------------- MAIN ----------------------
try:
    # Connexions
    print("Connecting accelerometer...")
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.connect((HOST, PORT))
    sock.settimeout(1)
    print("Accelerometer connected.")

    print("Connecting motor controller...")

    ser = serial.Serial(SERIAL_PORT, BAUDRATE, timeout=1)
    time.sleep(2)
    print("Motor controller connected.")

    stop_all()

    # Démarrage thread accélération
    accel_thread = threading.Thread(target=accel_reader, daemon=True)
    accel_thread.start()
    time.sleep(1)  # initialisation

    # Entrée utilisateur
    target_psi = float(input("Enter target Psi [-180,180]: "))
    target_theta = float(input("Enter target Theta [-90,90]: "))

    # Mouvement Psi → Motor 2
    move_motor_to_angle(target_psi, lambda : latest_psi,2 ,"Psi", min_angle=-180, max_angle=180)
    # Mouvement Theta → Motor 1
    move_motor_to_angle(target_theta, lambda : latest_theta,1 ,"Theta", min_angle=-90, max_angle=90)

    stop_all()
    print("\nObjectif atteint!")

finally:
    
    running = False
    stop_all()
    ser.close()
    sock.close()