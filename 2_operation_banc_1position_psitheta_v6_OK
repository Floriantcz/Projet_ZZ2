import socket
import serial
import time
import math
import threading

# ------------------- CONFIG -----------------------
HOST = '192.168.4.1'
PORT = 3535

SERIAL_PORT = 'COM3'
BAUDRATE = 115200

SENSITIVITY = 256000.0  # LSB / g

KP = 2.5
MAX_SPEED = 30
MIN_SPEED = 15

STOP_THRESHOLD = 0.9
CONTROL_PERIOD = 0.05
SETTLE_TIME = 1.0
TIMEOUT = 30

THETA_SAFE = 84.0
PSI_SAFE = 178.0   # JAMAIS ±180°

# ------------------- SHARED STATE ----------------
accel_lock = threading.Lock()
latest_theta = None
latest_psi = None
running = True

# ------------------- HELPERS -------------------
def send_command(cmd):
    ser.write((cmd + "\n").encode())
    time.sleep(0.01)

def stop_all():
    send_command("?stopall")

# ------------------- ACCEL -------------------
def get_accel_lsb():
    try:
        raw = sock.recv(1024).decode()
        for line in raw.split('\n'):
            if line.startswith('ASC3'):
                parts = line.strip().split('\t')
                if len(parts) >= 5:
                    return int(parts[2]), int(parts[3]), int(parts[4])
    except:
        pass
    return None

def lsb_to_g(ax, ay, az):
    return ax / SENSITIVITY, ay / SENSITIVITY, az / SENSITIVITY

# ------------------- ANGLES -------------------
def normalize_angle(angle):
    return (angle + 180) % 360 - 180

def shortest_angle_error(target, current):
    return (target - current + 180) % 360 - 180

def clamp_psi(angle):
    if angle >= 180:
        return PSI_SAFE
    if angle <= -180:
        return -PSI_SAFE
    return max(min(angle, PSI_SAFE), -PSI_SAFE)

def compute_angles(ax, ay, az):
    eps = 1e-12
    theta = math.degrees(math.atan2(ax, math.sqrt(ay*ay + az*az + eps)))
    psi   = math.degrees(math.atan2(ay, az))
    theta = max(min(theta, 90), -90)
    psi   = normalize_angle(psi)
    return theta, psi

# ------------------- ACCEL THREAD ----------------
def accel_reader():
    global latest_theta, latest_psi
    while running:
        data = get_accel_lsb()
        if data:
            ax_lsb, ay_lsb, az_lsb = data
            ax, ay, az = lsb_to_g(ax_lsb, ay_lsb, az_lsb)
            theta, psi = compute_angles(ax, ay, az)
            with accel_lock:
                latest_theta = theta
                latest_psi = psi

# ------------------- CONTROL --------------------
def move_motor_to_angle(target, get_angle, motor_id, name, min_angle, max_angle):

    target = max(min(target, max_angle), min_angle)

    print(f"\n--- Moving {name} to {target:.1f}° ---")
    start = time.time()

    while True:
        with accel_lock:
            current = get_angle()

        if current is None:
            continue

        current = normalize_angle(current)
        error = shortest_angle_error(target, current)

        print(f"{name} = {current:+.2f}° | error = {error:+.2f}°")

        if abs(error) < STOP_THRESHOLD:
            stop_all()
            print(f"{name} reached.")
            break

        speed = KP * error
        speed = max(min(speed, MAX_SPEED), -MAX_SPEED)

        if abs(error) > STOP_THRESHOLD and abs(speed) < MIN_SPEED:
            speed = math.copysign(MIN_SPEED, speed)

        send_command(f"?m{motor_id}={int(speed)}")

        if time.time() - start > TIMEOUT:
            stop_all()
            raise RuntimeError(f"{name} timeout")

        time.sleep(CONTROL_PERIOD)

    time.sleep(SETTLE_TIME)

# ------------------- MAIN ----------------------
try:
    print("Connecting accelerometer...")
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.connect((HOST, PORT))
    sock.settimeout(1)
    print("Accelerometer connected.")

    print("Connecting motor controller...")
    ser = serial.Serial(SERIAL_PORT, BAUDRATE, timeout=1)
    time.sleep(2)
    print("Motor controller connected.")

    stop_all()

    accel_thread = threading.Thread(target=accel_reader, daemon=True)
    accel_thread.start()
    time.sleep(1)

    target_psi = float(input("Enter target Psi [-180,180]: "))
    target_theta = float(input("Enter target Theta [-90,90]: "))

    target_theta = max(min(target_theta, THETA_SAFE), -THETA_SAFE)
    target_psi = clamp_psi(target_psi)

    move_motor_to_angle(
        target_theta,
        lambda: latest_theta,
        1,
        "Theta",
        -THETA_SAFE,
        THETA_SAFE
    )

    move_motor_to_angle(
        target_psi,
        lambda: latest_psi,
        2,
        "Psi",
        -PSI_SAFE,
        PSI_SAFE
    )

    stop_all()
    print("\nObjectif atteint!")

finally:
    running = False
    stop_all()
    ser.close()
    sock.close()
