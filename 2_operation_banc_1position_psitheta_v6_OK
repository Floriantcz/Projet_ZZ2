import socket
import serial
import time
import math
import threading
import numpy as np

# ------------------- CONFIGURATION -----------------------
HOST = '192.168.4.1'
PORT = 3535

SERIAL_PORT = 'COM7'
BAUDRATE = 115200

SENSITIVITY = 256000     # LSB / g

KP = 2.5
MAX_SPEED = 30
MIN_SPEED = 15

STOP_THRESHOLD = 0.9
CONTROL_PERIOD = 0.05
SETTLE_TIME = 2.0
TIMEOUT = 30

# ------------------- SHARED STATE ------------------------
accel_lock = threading.Lock()
latest_theta = None
latest_psi = None
running = True

# ------------------- CONNECTIONS -------------------------
print(f"Connecting to accelerometer {HOST}:{PORT}...")
sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
sock.connect((HOST, PORT))
sock.settimeout(1)
print("Accelerometer connected.")

print("Connecting to motor controller...")
ser = serial.Serial(SERIAL_PORT, BAUDRATE, timeout=1)
time.sleep(2)
print("Motor controller connected.")

# ------------------- HELPERS -----------------------------
def send_command(cmd):
    ser.write((cmd + "\n").encode())
    time.sleep(0.01)

def stop_all():
    send_command("?stopall")

def get_accel_lsb():
    try:
        raw = sock.recv(1024).decode()
        for line in raw.split('\n'):
            if line.startswith('ASC3'):
                parts = line.strip().split('\t')
                if len(parts) >= 5:
                    return int(parts[2]), int(parts[3]), int(parts[4])
    except:
        pass
    return None

def lsb_to_g(ax, ay, az):
    return ax / SENSITIVITY, ay / SENSITIVITY, az / SENSITIVITY

def normalize_angle(angle):
    """Angle → [-180, 180]"""
    return (angle + 180) % 360 - 180

# ------------------- ANGLES (VERSION FIABLE) ----------------
def compute_angles(ax, ay, az):
    """
    Theta ∈ [-90,90]
    Psi   ∈ [-180,180] (robuste)
    """
    eps = 1e-12

    theta = math.degrees(math.atan2(ax, math.sqrt(ay*ay + az*az + eps)))
    psi   = math.degrees(math.atan2(ay, az))
    psi   = normalize_angle(psi)

    return theta, psi

# ------------------- ACCELEROMETER THREAD ----------------
def accel_reader():
    global latest_theta, latest_psi
    while running:
        data = get_accel_lsb()
        if data:
            ax_lsb, ay_lsb, az_lsb = data
            ax, ay, az = lsb_to_g(ax_lsb, ay_lsb, az_lsb)
            theta, psi = compute_angles(ax, ay, az)

            with accel_lock:
                latest_theta = theta
                latest_psi = psi

# ------------------- CONTROL FUNCTION --------------------
def move_motor_to_angle(target_angle, motor_id, angle_name):
    print(f"\n--- Moving M{motor_id} to {angle_name} = {target_angle:.2f}° ---")
    start_time = time.time()

    while True:
        with accel_lock:
            current_angle = latest_psi if motor_id == 2 else latest_theta

        if current_angle is None:
            continue

        error = target_angle - current_angle
        print(f"{angle_name} = {current_angle:+.2f}° | error = {error:+.2f}°")

        if abs(error) < STOP_THRESHOLD:
            stop_all()
            print(f"{angle_name} target reached.")
            break

        speed = KP * error
        speed = max(min(speed, MAX_SPEED), -MAX_SPEED)

        if abs(speed) < MIN_SPEED:
            speed = math.copysign(MIN_SPEED, speed)

        send_command(f"?m{motor_id}={int(speed)}")

        if time.time() - start_time > TIMEOUT:
            stop_all()
            raise RuntimeError(f"Timeout reaching {angle_name}")

        time.sleep(CONTROL_PERIOD)

    time.sleep(SETTLE_TIME)

# ------------------- MAIN -------------------------------
try:
    stop_all()

    target_psi   = float(input("Enter target psi [-180,180]: "))
    target_theta = float(input("Enter target theta [-90,90]: "))

    accel_thread = threading.Thread(target=accel_reader, daemon=True)
    accel_thread.start()
    time.sleep(1)

    move_motor_to_angle(target_psi, motor_id=2, angle_name="Psi")
    move_motor_to_angle(target_theta, motor_id=1, angle_name="Theta")

    stop_all()
    print("\nOrientation reached successfully.")

finally:
    running = False
    stop_all()
    ser.close()
    sock.close()
